(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@sweetalert2/ngx-sweetalert2', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/common'], factory) :
    (global = global || self, factory((global.Sweetalert2 = global.Sweetalert2 || {}, global.Sweetalert2['ngx-sweetalert2'] = {}), global.ng.core, global.rxjs, global.rxjs.operators, global.ng.common));
}(this, (function (exports, core, rxjs, operators, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/di.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var swalProviderToken = new core.InjectionToken('@sweetalert2/ngx-sweetalert2#swalProvider');
    /** @type {?} */
    var fireOnInitToken = new core.InjectionToken('@sweetalert2/ngx-sweetalert2#fireOnInit');
    /** @type {?} */
    var dismissOnDestroyToken = new core.InjectionToken('@sweetalert2/ngx-sweetalert2#dismissOnDestroy');

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sweetalert2-loader.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SweetAlert2LoaderService = /** @class */ (function () {
        // Using any because Angular metadata generator does not understand a pure TS type here
        function SweetAlert2LoaderService(swalProvider) {
            this.swalProvider = swalProvider;
        }
        Object.defineProperty(SweetAlert2LoaderService.prototype, "swal", {
            get: /**
             * @return {?}
             */
            function () {
                if (!this.swalPromiseCache) {
                    this.preloadSweetAlertLibrary();
                }
                return (/** @type {?} */ (this.swalPromiseCache));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SweetAlert2LoaderService.prototype.preloadSweetAlertLibrary = /**
         * @return {?}
         */
        function () {
            if (this.swalPromiseCache)
                return;
            /** @type {?} */
            var libPromise = isLoader(this.swalProvider)
                ? this.swalProvider()
                : Promise.resolve(this.swalProvider);
            this.swalPromiseCache = libPromise.then((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return isDefaultExport(value) ? value : value.default; }));
            /**
             * @param {?} value
             * @return {?}
             */
            function isLoader(value) {
                return typeof value === 'function' && ((/** @type {?} */ (value))).version === undefined;
            }
            /**
             * @param {?} value
             * @return {?}
             */
            function isDefaultExport(value) {
                return typeof value === 'function';
            }
        };
        SweetAlert2LoaderService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SweetAlert2LoaderService.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [swalProviderToken,] }] }
        ]; };
        return SweetAlert2LoaderService;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        SweetAlert2LoaderService.prototype.swalProvider;
        /**
         * @type {?}
         * @private
         */
        SweetAlert2LoaderService.prototype.swalPromiseCache;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/swal.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * <swal> component. See the README.md for usage.
     *
     * It contains a bunch of \@Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
     * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
     * to SweetAlert2, but also is type-safe.
     *
     * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many \@Inputs,
     *     take a look at [swalOptions], that lets you pass a full {\@link SweetAlertOptions} object.
     *
     * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
     *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
     *     If you are really concerned about performance and/or don't care about the API and its convenient integration
     *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
     *
     * /!\ Some SweetAlert options aren't \@Inputs but \@Outputs: onBeforeOpen, onOpen, onClose and onAfterClose
     *     (but without "on*" prefix to respect community standards).
     *     However, preConfirm and inputValidator are still \@Inputs because there are not event handlers, there can't be
     *     multiple listeners and we need the values they can/must return.
     */
    var SwalComponent = /** @class */ (function () {
        function SwalComponent(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
            this.sweetAlert2Loader = sweetAlert2Loader;
            this.moduleLevelFireOnInit = moduleLevelFireOnInit;
            this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
            /**
             * Emits an event when the modal DOM element has been created.
             * Useful to perform DOM mutations before the modal is shown.
             */
            this.beforeOpen = new core.EventEmitter();
            /**
             * Emits an event when the modal is shown.
             */
            this.open = new core.EventEmitter();
            /**
             * Emits an event when the modal DOM is rendered.
             */
            this.render = new core.EventEmitter();
            /**
             * Emits an event when the modal will be closed.
             * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
             */
            this.close = new core.EventEmitter();
            /**
             * Emits an event after the modal had been closed.
             * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
             */
            this.afterClose = new core.EventEmitter();
            /**
             * Emits when the user clicks "Confirm".
             * Bears a value when using "input", resolved "preConfirm", etc.
             *
             * Example:
             *     <swal (confirm)="handleConfirm($event)"></swal>
             *
             *     public handleConfirm(email: string): void {
             *         // ... save user email
             *     }
             */
            this.confirm = new core.EventEmitter();
            /**
             * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
             * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
             * The reason is `undefined` when {\@link dismiss} is called.
             *
             * Example:
             *     <swal (cancel)="handleCancel($event)"></swal>
             *
             *     public handleCancel(reason: DismissReason | undefined): void {
             *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
             *         // ... do something
             *     }
             */
            this.cancel = new core.EventEmitter();
            /**
             * This Set retains the properties that have been changed from \@Inputs, so we can know precisely
             * what options we have to send to {\@link Swal.fire}.
             */
            this.touchedProps = new Set();
            /**
             * A function of signature `(propName: string): void` that adds a given property name to the list of
             * touched properties, ie. {\@link touchedProps}.
             */
            this.markTouched = this.touchedProps.add.bind(this.touchedProps);
            /**
             * Is the SweetAlert2 modal represented by this component currently opened?
             */
            this.isCurrentlyShown = false;
        }
        Object.defineProperty(SwalComponent.prototype, "swalOptions", {
            /**
             * Computes the options object that will get passed to SweetAlert2.
             * Only the properties that have been set at least once on this component will be returned.
             * Mostly for internal usage.
             */
            get: /**
             * Computes the options object that will get passed to SweetAlert2.
             * Only the properties that have been set at least once on this component will be returned.
             * Mostly for internal usage.
             * @return {?}
             */
            function () {
                var _this = this;
                /** @type {?} */
                var options = {};
                //=> We will compute the options object based on the option keys that are known to have changed.
                //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
                //   avoiding side effects.
                this.touchedProps.forEach((/**
                 * @param {?} prop
                 * @return {?}
                 */
                function (prop) {
                    options[prop] = _this[(/** @type {?} */ (prop))];
                }));
                return options;
            },
            /**
             * An object of SweetAlert2 native options, useful if:
             *  - you don't want to use the @Inputs for practical/philosophical reasons ;
             *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
             *
             * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
             *     previous properties you want to erase again.
             *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
             *
             * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
             */
            set: /**
             * An object of SweetAlert2 native options, useful if:
             *  - you don't want to use the \@Inputs for practical/philosophical reasons ;
             *  - there are missing \@Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
             *
             * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
             *     previous properties you want to erase again.
             *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
             *
             * /!\ Be aware that the options defined in this object will override the \@Inputs of the same name.
             * @param {?} options
             * @return {?}
             */
            function (options) {
                //=> Update properties
                Object.assign(this, options);
                //=> Mark changed properties as touched
                /** @type {?} */
                var touchedKeys = (/** @type {?} */ (Object.keys(options)));
                touchedKeys.forEach(this.markTouched);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SwalComponent.prototype, "swalVisible", {
            get: /**
             * @return {?}
             */
            function () {
                return this.isCurrentlyShown;
            },
            set: /**
             * @param {?} visible
             * @return {?}
             */
            function (visible) {
                visible ? this.fire() : this.dismiss();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Angular lifecycle hook.
         * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
         * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
         * causing no delay.
         */
        /**
         * Angular lifecycle hook.
         * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
         * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
         * causing no delay.
         * @return {?}
         */
        SwalComponent.prototype.ngOnInit = /**
         * Angular lifecycle hook.
         * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
         * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
         * causing no delay.
         * @return {?}
         */
        function () {
            //=> Preload SweetAlert2 library in case this component is activated.
            this.sweetAlert2Loader.preloadSweetAlertLibrary();
        };
        /**
         * Angular lifecycle hook.
         * Fires the modal, if the component or module is configured to do so.
         */
        /**
         * Angular lifecycle hook.
         * Fires the modal, if the component or module is configured to do so.
         * @return {?}
         */
        SwalComponent.prototype.ngAfterViewInit = /**
         * Angular lifecycle hook.
         * Fires the modal, if the component or module is configured to do so.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var fireOnInit = this.swalFireOnInit === undefined
                ? this.moduleLevelFireOnInit
                : this.swalFireOnInit;
            fireOnInit && this.fire();
        };
        /**
         * Angular lifecycle hook.
         * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
         */
        /**
         * Angular lifecycle hook.
         * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
         * @param {?} changes
         * @return {?}
         */
        SwalComponent.prototype.ngOnChanges = /**
         * Angular lifecycle hook.
         * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
            //   send it with the next fire() or update() calls.
            Object.keys(changes)
                //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
                .filter((/**
             * @param {?} prop
             * @return {?}
             */
            function (prop) { return !prop.startsWith('swal'); }))
                .forEach(this.markTouched);
            //=> Eventually trigger re-render if the modal is open.
            void this.update();
        };
        /**
         * Angular lifecycle hook.
         * Closes the SweetAlert when the component is destroyed.
         */
        /**
         * Angular lifecycle hook.
         * Closes the SweetAlert when the component is destroyed.
         * @return {?}
         */
        SwalComponent.prototype.ngOnDestroy = /**
         * Angular lifecycle hook.
         * Closes the SweetAlert when the component is destroyed.
         * @return {?}
         */
        function () {
            //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
            /** @type {?} */
            var dismissOnDestroy = this.swalDismissOnDestroy === undefined
                ? this.moduleLevelDismissOnDestroy
                : this.swalDismissOnDestroy;
            dismissOnDestroy && this.dismiss();
        };
        /**
         * Shows the SweetAlert.
         *
         * Returns the SweetAlert2 promise for convenience and use in code behind templates.
         * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
         */
        /**
         * Shows the SweetAlert.
         *
         * Returns the SweetAlert2 promise for convenience and use in code behind templates.
         * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
         * @return {?}
         */
        SwalComponent.prototype.fire = /**
         * Shows the SweetAlert.
         *
         * Returns the SweetAlert2 promise for convenience and use in code behind templates.
         * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
         * @return {?}
         */
        function () {
            return __awaiter(this, void 0, void 0, function () {
                var swal, options, result;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.sweetAlert2Loader.swal];
                        case 1:
                            swal = _a.sent();
                            //=> Build the SweetAlert2 options
                            options = __assign({}, this.swalOptions, { onBeforeOpen: (/**
                                 * @param {?} modalElement
                                 * @return {?}
                                 */
                                function (modalElement) {
                                    _this.beforeOpen.emit({ modalElement: modalElement });
                                }), onOpen: (/**
                                 * @param {?} modalElement
                                 * @return {?}
                                 */
                                function (modalElement) {
                                    _this.isCurrentlyShown = true;
                                    _this.open.emit({ modalElement: modalElement });
                                }), onRender: (/**
                                 * @param {?} modalElement
                                 * @return {?}
                                 */
                                function (modalElement) {
                                    _this.render.emit({ modalElement: modalElement });
                                }), onClose: (/**
                                 * @param {?} modalElement
                                 * @return {?}
                                 */
                                function (modalElement) {
                                    _this.isCurrentlyShown = false;
                                    _this.close.emit({ modalElement: modalElement });
                                }), onAfterClose: (/**
                                 * @return {?}
                                 */
                                function () {
                                    _this.afterClose.emit();
                                }) });
                            //=> Show the Swal! And wait for confirmation or dimissal.
                            return [4 /*yield*/, swal.fire(options)];
                        case 2:
                            result = _a.sent();
                            //=> Emit on (confirm) or (cancel)
                            if ('value' in result) {
                                this.confirm.emit(result.value);
                            }
                            else {
                                this.cancel.emit(result.dismiss);
                            }
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        /**
         * Closes the modal, if opened.
         *
         * @param result The value that the modal will resolve with, triggering either (confirm) or (cancel).
         *               If the argument is not passed, (dimiss) will emit `undefined`.
         *               See {@link Swal.close}
         */
        /**
         * Closes the modal, if opened.
         *
         * @param {?=} result The value that the modal will resolve with, triggering either (confirm) or (cancel).
         *               If the argument is not passed, (dimiss) will emit `undefined`.
         *               See {\@link Swal.close}
         * @return {?}
         */
        SwalComponent.prototype.dismiss = /**
         * Closes the modal, if opened.
         *
         * @param {?=} result The value that the modal will resolve with, triggering either (confirm) or (cancel).
         *               If the argument is not passed, (dimiss) will emit `undefined`.
         *               See {\@link Swal.close}
         * @return {?}
         */
        function (result) {
            return __awaiter(this, void 0, void 0, function () {
                var swal;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.isCurrentlyShown)
                                return [2 /*return*/];
                            return [4 /*yield*/, this.sweetAlert2Loader.swal];
                        case 1:
                            swal = _a.sent();
                            swal.close(result);
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
         * If the modal is not opened, the component options will simply be updated and that's it.
         *
         * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
         *
         * @param options
         */
        /**
         * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
         * If the modal is not opened, the component options will simply be updated and that's it.
         *
         * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
         *
         * @param {?=} options
         * @return {?}
         */
        SwalComponent.prototype.update = /**
         * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
         * If the modal is not opened, the component options will simply be updated and that's it.
         *
         * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
         *
         * @param {?=} options
         * @return {?}
         */
        function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var swal, allOptions, updatableOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (options) {
                                this.swalOptions = options;
                            }
                            if (!this.isCurrentlyShown)
                                return [2 /*return*/];
                            return [4 /*yield*/, this.sweetAlert2Loader.swal];
                        case 1:
                            swal = _a.sent();
                            allOptions = this.swalOptions;
                            updatableOptions = Object.keys(allOptions)
                                .filter((/**
                             * @param {?} key
                             * @return {?}
                             */
                            function (key) { return swal.isUpdatableParameter(key); }))
                                .reduce((/**
                             * @param {?} obj
                             * @param {?} key
                             * @return {?}
                             */
                            function (obj, key) {
                                obj[key] = allOptions[key];
                                return obj;
                            }), (/** @type {?} */ ({})));
                            swal.update(updatableOptions);
                            return [2 /*return*/];
                    }
                });
            });
        };
        SwalComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'swal',
                        template: '',
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SwalComponent.ctorParameters = function () { return [
            { type: SweetAlert2LoaderService },
            { type: Boolean, decorators: [{ type: core.Inject, args: [fireOnInitToken,] }] },
            { type: Boolean, decorators: [{ type: core.Inject, args: [dismissOnDestroyToken,] }] }
        ]; };
        SwalComponent.propDecorators = {
            title: [{ type: core.Input }],
            titleText: [{ type: core.Input }],
            text: [{ type: core.Input }],
            html: [{ type: core.Input }],
            footer: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            iconHtml: [{ type: core.Input }],
            backdrop: [{ type: core.Input }],
            toast: [{ type: core.Input }],
            target: [{ type: core.Input }],
            input: [{ type: core.Input }],
            width: [{ type: core.Input }],
            padding: [{ type: core.Input }],
            background: [{ type: core.Input }],
            position: [{ type: core.Input }],
            grow: [{ type: core.Input }],
            showClass: [{ type: core.Input }],
            hideClass: [{ type: core.Input }],
            customClass: [{ type: core.Input }],
            timer: [{ type: core.Input }],
            animation: [{ type: core.Input }],
            heightAuto: [{ type: core.Input }],
            allowOutsideClick: [{ type: core.Input }],
            allowEscapeKey: [{ type: core.Input }],
            allowEnterKey: [{ type: core.Input }],
            stopKeydownPropagation: [{ type: core.Input }],
            keydownListenerCapture: [{ type: core.Input }],
            showConfirmButton: [{ type: core.Input }],
            showCancelButton: [{ type: core.Input }],
            confirmButtonText: [{ type: core.Input }],
            cancelButtonText: [{ type: core.Input }],
            confirmButtonColor: [{ type: core.Input }],
            cancelButtonColor: [{ type: core.Input }],
            confirmButtonAriaLabel: [{ type: core.Input }],
            cancelButtonAriaLabel: [{ type: core.Input }],
            buttonsStyling: [{ type: core.Input }],
            reverseButtons: [{ type: core.Input }],
            focusConfirm: [{ type: core.Input }],
            focusCancel: [{ type: core.Input }],
            showCloseButton: [{ type: core.Input }],
            closeButtonHtml: [{ type: core.Input }],
            closeButtonAriaLabel: [{ type: core.Input }],
            showLoaderOnConfirm: [{ type: core.Input }],
            preConfirm: [{ type: core.Input }],
            imageUrl: [{ type: core.Input }],
            imageWidth: [{ type: core.Input }],
            imageHeight: [{ type: core.Input }],
            imageAlt: [{ type: core.Input }],
            inputPlaceholder: [{ type: core.Input }],
            inputValue: [{ type: core.Input }],
            inputOptions: [{ type: core.Input }],
            inputAutoTrim: [{ type: core.Input }],
            inputAttributes: [{ type: core.Input }],
            inputValidator: [{ type: core.Input }],
            validationMessage: [{ type: core.Input }],
            progressSteps: [{ type: core.Input }],
            currentProgressStep: [{ type: core.Input }],
            progressStepsDistance: [{ type: core.Input }],
            scrollbarPadding: [{ type: core.Input }],
            swalOptions: [{ type: core.Input }],
            swalFireOnInit: [{ type: core.Input }],
            swalDismissOnDestroy: [{ type: core.Input }],
            swalVisible: [{ type: core.Input }],
            beforeOpen: [{ type: core.Output }],
            open: [{ type: core.Output }],
            render: [{ type: core.Output }],
            close: [{ type: core.Output }],
            afterClose: [{ type: core.Output }],
            confirm: [{ type: core.Output }],
            cancel: [{ type: core.Output }]
        };
        return SwalComponent;
    }());
    if (false) {
        /** @type {?} */
        SwalComponent.prototype.title;
        /** @type {?} */
        SwalComponent.prototype.titleText;
        /** @type {?} */
        SwalComponent.prototype.text;
        /** @type {?} */
        SwalComponent.prototype.html;
        /** @type {?} */
        SwalComponent.prototype.footer;
        /** @type {?} */
        SwalComponent.prototype.icon;
        /** @type {?} */
        SwalComponent.prototype.iconHtml;
        /** @type {?} */
        SwalComponent.prototype.backdrop;
        /** @type {?} */
        SwalComponent.prototype.toast;
        /** @type {?} */
        SwalComponent.prototype.target;
        /** @type {?} */
        SwalComponent.prototype.input;
        /** @type {?} */
        SwalComponent.prototype.width;
        /** @type {?} */
        SwalComponent.prototype.padding;
        /** @type {?} */
        SwalComponent.prototype.background;
        /** @type {?} */
        SwalComponent.prototype.position;
        /** @type {?} */
        SwalComponent.prototype.grow;
        /** @type {?} */
        SwalComponent.prototype.showClass;
        /** @type {?} */
        SwalComponent.prototype.hideClass;
        /** @type {?} */
        SwalComponent.prototype.customClass;
        /** @type {?} */
        SwalComponent.prototype.timer;
        /**
         * @deprecated Use showClass and hideClass instead
         * @type {?}
         */
        SwalComponent.prototype.animation;
        /** @type {?} */
        SwalComponent.prototype.heightAuto;
        /** @type {?} */
        SwalComponent.prototype.allowOutsideClick;
        /** @type {?} */
        SwalComponent.prototype.allowEscapeKey;
        /** @type {?} */
        SwalComponent.prototype.allowEnterKey;
        /** @type {?} */
        SwalComponent.prototype.stopKeydownPropagation;
        /** @type {?} */
        SwalComponent.prototype.keydownListenerCapture;
        /** @type {?} */
        SwalComponent.prototype.showConfirmButton;
        /** @type {?} */
        SwalComponent.prototype.showCancelButton;
        /** @type {?} */
        SwalComponent.prototype.confirmButtonText;
        /** @type {?} */
        SwalComponent.prototype.cancelButtonText;
        /** @type {?} */
        SwalComponent.prototype.confirmButtonColor;
        /** @type {?} */
        SwalComponent.prototype.cancelButtonColor;
        /** @type {?} */
        SwalComponent.prototype.confirmButtonAriaLabel;
        /** @type {?} */
        SwalComponent.prototype.cancelButtonAriaLabel;
        /** @type {?} */
        SwalComponent.prototype.buttonsStyling;
        /** @type {?} */
        SwalComponent.prototype.reverseButtons;
        /** @type {?} */
        SwalComponent.prototype.focusConfirm;
        /** @type {?} */
        SwalComponent.prototype.focusCancel;
        /** @type {?} */
        SwalComponent.prototype.showCloseButton;
        /** @type {?} */
        SwalComponent.prototype.closeButtonHtml;
        /** @type {?} */
        SwalComponent.prototype.closeButtonAriaLabel;
        /** @type {?} */
        SwalComponent.prototype.showLoaderOnConfirm;
        /** @type {?} */
        SwalComponent.prototype.preConfirm;
        /** @type {?} */
        SwalComponent.prototype.imageUrl;
        /** @type {?} */
        SwalComponent.prototype.imageWidth;
        /** @type {?} */
        SwalComponent.prototype.imageHeight;
        /** @type {?} */
        SwalComponent.prototype.imageAlt;
        /** @type {?} */
        SwalComponent.prototype.inputPlaceholder;
        /** @type {?} */
        SwalComponent.prototype.inputValue;
        /** @type {?} */
        SwalComponent.prototype.inputOptions;
        /** @type {?} */
        SwalComponent.prototype.inputAutoTrim;
        /** @type {?} */
        SwalComponent.prototype.inputAttributes;
        /** @type {?} */
        SwalComponent.prototype.inputValidator;
        /** @type {?} */
        SwalComponent.prototype.validationMessage;
        /** @type {?} */
        SwalComponent.prototype.progressSteps;
        /** @type {?} */
        SwalComponent.prototype.currentProgressStep;
        /** @type {?} */
        SwalComponent.prototype.progressStepsDistance;
        /** @type {?} */
        SwalComponent.prototype.scrollbarPadding;
        /**
         * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.
         * When left undefined (default), the value will be inherited from the module configuration, which is `false`.
         *
         * Example:
         *     <swal *ngIf="error" [title]="error.title" [text]="error.text" icon="error" [swalFireOnInit]="true"></swal>
         * @type {?}
         */
        SwalComponent.prototype.swalFireOnInit;
        /**
         * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.
         * When left undefined (default), the value will be inherited from the module configuration, which is `true`.
         * @type {?}
         */
        SwalComponent.prototype.swalDismissOnDestroy;
        /**
         * Emits an event when the modal DOM element has been created.
         * Useful to perform DOM mutations before the modal is shown.
         * @type {?}
         */
        SwalComponent.prototype.beforeOpen;
        /**
         * Emits an event when the modal is shown.
         * @type {?}
         */
        SwalComponent.prototype.open;
        /**
         * Emits an event when the modal DOM is rendered.
         * @type {?}
         */
        SwalComponent.prototype.render;
        /**
         * Emits an event when the modal will be closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         * @type {?}
         */
        SwalComponent.prototype.close;
        /**
         * Emits an event after the modal had been closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         * @type {?}
         */
        SwalComponent.prototype.afterClose;
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         * @type {?}
         */
        SwalComponent.prototype.confirm;
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
         * The reason is `undefined` when {\@link dismiss} is called.
         *
         * Example:
         *     <swal (cancel)="handleCancel($event)"></swal>
         *
         *     public handleCancel(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         * @type {?}
         */
        SwalComponent.prototype.cancel;
        /**
         * This Set retains the properties that have been changed from \@Inputs, so we can know precisely
         * what options we have to send to {\@link Swal.fire}.
         * @type {?}
         * @private
         */
        SwalComponent.prototype.touchedProps;
        /**
         * A function of signature `(propName: string): void` that adds a given property name to the list of
         * touched properties, ie. {\@link touchedProps}.
         * @type {?}
         * @private
         */
        SwalComponent.prototype.markTouched;
        /**
         * Is the SweetAlert2 modal represented by this component currently opened?
         * @type {?}
         * @private
         */
        SwalComponent.prototype.isCurrentlyShown;
        /**
         * @type {?}
         * @private
         */
        SwalComponent.prototype.sweetAlert2Loader;
        /**
         * @type {?}
         * @private
         */
        SwalComponent.prototype.moduleLevelFireOnInit;
        /**
         * @type {?}
         * @private
         */
        SwalComponent.prototype.moduleLevelDismissOnDestroy;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/swal.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * [swal] directive. It takes a value that defines the SweetAlert and can be of three types:
     *
     * 1) A simple array of two or three strings defining [title, text, icon] - the icon being optional, ex:
     *
     *    <button [swal]="['Title', 'Text']">Click me</button>
     *
     * 2) A native SweetAlert2 options object, ex:
     *
     *    <button [swal]="{ title: 'Title', text: 'Text' }">Click me</button>
     *
     * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:
     *
     *    <button [swal]="mySwal">Click me</button>
     *    <swal #mySwal title="Title" text="Text"></swal>
     */
    var SwalDirective = /** @class */ (function () {
        function SwalDirective(viewContainerRef, resolver) {
            this.viewContainerRef = viewContainerRef;
            this.resolver = resolver;
            /**
             * Emits when the user clicks "Confirm".
             * Bears a value when using "input", resolved "preConfirm", etc.
             *
             * Example:
             *     <swal (confirm)="handleConfirm($event)"></swal>
             *
             *     public handleConfirm(email: string): void {
             *         // ... save user email
             *     }
             */
            this.confirm = new core.EventEmitter();
            /**
             * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
             * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
             * The reason is `undefined` when {\@link dismiss} is called.
             *
             * Example:
             *     <swal (cancel)="handleCancel($event)"></swal>
             *
             *     public handleCancel(reason: DismissReason | undefined): void {
             *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
             *         // ... do something
             *     }
             */
            this.cancel = new core.EventEmitter();
        }
        Object.defineProperty(SwalDirective.prototype, "swal", {
            /**
             * SweetAlert2 options or a SwalComponent instance.
             * See the class doc block for more informations.
             */
            set: /**
             * SweetAlert2 options or a SwalComponent instance.
             * See the class doc block for more informations.
             * @param {?} options
             * @return {?}
             */
            function (options) {
                var _a;
                if (options instanceof SwalComponent) {
                    this.swalInstance = options;
                }
                else if (Array.isArray(options)) {
                    this.swalOptions = {};
                    _a = __read(options, 3), this.swalOptions.title = _a[0], this.swalOptions.text = _a[1], this.swalOptions.icon = _a[2];
                }
                else {
                    this.swalOptions = options;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * OnInit lifecycle handler.
         * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
         * (cancel) outputs to reemit on the directive.
         */
        /**
         * OnInit lifecycle handler.
         * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
         * (cancel) outputs to reemit on the directive.
         * @return {?}
         */
        SwalDirective.prototype.ngOnInit = /**
         * OnInit lifecycle handler.
         * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
         * (cancel) outputs to reemit on the directive.
         * @return {?}
         */
        function () {
            if (!this.swalInstance) {
                /** @type {?} */
                var factory = this.resolver.resolveComponentFactory(SwalComponent);
                this.swalRef = this.viewContainerRef.createComponent(factory);
                this.swalInstance = this.swalRef.instance;
            }
        };
        /**
         * OnDestroy lifecycle handler.
         * Destroys the dynamically-created SwalComponent.
         */
        /**
         * OnDestroy lifecycle handler.
         * Destroys the dynamically-created SwalComponent.
         * @return {?}
         */
        SwalDirective.prototype.ngOnDestroy = /**
         * OnDestroy lifecycle handler.
         * Destroys the dynamically-created SwalComponent.
         * @return {?}
         */
        function () {
            if (this.swalRef) {
                this.swalRef.destroy();
            }
        };
        /**
         * Click handler.
         * The directive listens for onclick events on its host element.
         * When this happens, it shows the <swal> attached to this directive.
         */
        /**
         * Click handler.
         * The directive listens for onclick events on its host element.
         * When this happens, it shows the <swal> attached to this directive.
         * @param {?} event
         * @return {?}
         */
        SwalDirective.prototype.onClick = /**
         * Click handler.
         * The directive listens for onclick events on its host element.
         * When this happens, it shows the <swal> attached to this directive.
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            event.preventDefault();
            event.stopImmediatePropagation();
            event.stopPropagation();
            if (!this.swalInstance)
                return;
            if (this.swalOptions) {
                this.swalInstance.swalOptions = this.swalOptions;
            }
            /** @type {?} */
            var swalClosed = new rxjs.Subject();
            this.swalInstance.confirm.asObservable().pipe(operators.takeUntil(swalClosed)).subscribe((/**
             * @param {?} v
             * @return {?}
             */
            function (v) { return _this.confirm.emit(v); }));
            this.swalInstance.cancel.asObservable().pipe(operators.takeUntil(swalClosed)).subscribe((/**
             * @param {?} v
             * @return {?}
             */
            function (v) { return _this.cancel.emit(v); }));
            this.swalInstance.fire().then((/**
             * @return {?}
             */
            function () { return swalClosed.next(); }));
        };
        SwalDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[swal]'
                    },] }
        ];
        /** @nocollapse */
        SwalDirective.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.ComponentFactoryResolver }
        ]; };
        SwalDirective.propDecorators = {
            swal: [{ type: core.Input }],
            confirm: [{ type: core.Output }],
            cancel: [{ type: core.Output }],
            onClick: [{ type: core.HostListener, args: ['click', ['$event'],] }]
        };
        return SwalDirective;
    }());
    if (false) {
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         * @type {?}
         */
        SwalDirective.prototype.confirm;
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
         * The reason is `undefined` when {\@link dismiss} is called.
         *
         * Example:
         *     <swal (cancel)="handleCancel($event)"></swal>
         *
         *     public handleCancel(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         * @type {?}
         */
        SwalDirective.prototype.cancel;
        /**
         * When the user does not provides a SwalComponent instance, we create it on-the-fly and assign the plain-object
         * options to it.
         * This fields keeps a reference to the dynamically-created <swal>, to destroy it along this directive instance.
         * @type {?}
         * @private
         */
        SwalDirective.prototype.swalRef;
        /**
         * An instance of the <swal> component that this directive controls.
         * Could be an instance passed by the user, otherwise it's the instance we've dynamically created.
         * @type {?}
         * @private
         */
        SwalDirective.prototype.swalInstance;
        /**
         * Holds the native SweetAlert2 options.
         * Empty when the user passed an existing SwalComponent instance.
         * @type {?}
         * @private
         */
        SwalDirective.prototype.swalOptions;
        /**
         * @type {?}
         * @private
         */
        SwalDirective.prototype.viewContainerRef;
        /**
         * @type {?}
         * @private
         */
        SwalDirective.prototype.resolver;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/swal-events.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Emitted when a SweetAlert modal gets created in memory, just before it's displayed.
     * @record
     */
    function BeforeOpenEvent() { }
    if (false) {
        /** @type {?} */
        BeforeOpenEvent.prototype.modalElement;
    }
    /**
     * Emitted when a SweetAlert modal gets displayed.
     * @record
     */
    function OpenEvent() { }
    if (false) {
        /** @type {?} */
        OpenEvent.prototype.modalElement;
    }
    /**
     * Emitted when a SweetAlert modal gets rendered.
     * @record
     */
    function RenderEvent() { }
    if (false) {
        /** @type {?} */
        RenderEvent.prototype.modalElement;
    }
    /**
     * Emitted when a SweetAlert modal gets closed (because it's been confirmed, cancelled, or for no reason at all).
     * @record
     */
    function CloseEvent() { }
    if (false) {
        /** @type {?} */
        CloseEvent.prototype.modalElement;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/swal-portal-targets.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function SwalPortalTarget() { }
    if (false) {
        /** @type {?|undefined} */
        SwalPortalTarget.prototype.options;
        /**
         * @param {?} swal
         * @return {?}
         */
        SwalPortalTarget.prototype.element = function (swal) { };
    }
    /**
     * Represents an object of targets for <swal> portals (use with *swalPortal directive).
     * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is
     * shown, so this object lets us reference those functions safely and in a statically-typed manner.
     */
    var SwalPortalTargets = /** @class */ (function () {
        function SwalPortalTargets() {
            /**
             * Targets the modal close button block contents.
             */
            this.closeButton = {
                element: (/**
                 * @param {?} swal
                 * @return {?}
                 */
                function (swal) { return swal.getCloseButton(); }),
                options: { showCloseButton: true }
            };
            /**
             * Targets the modal title block contents.
             */
            this.title = {
                element: (/**
                 * @param {?} swal
                 * @return {?}
                 */
                function (swal) { return swal.getTitle(); }),
                // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
                options: { title: ' ' }
            };
            /**
             * Targets the modal text block contents (that is another block inside the first content block, so you can still
             * use other modal features like Swal inputs, that are situated inside that parent content block).
             */
            this.content = {
                element: (/**
                 * @param {?} swal
                 * @return {?}
                 */
                function (swal) { return swal.getHtmlContainer(); }),
                // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
                options: { text: ' ' }
            };
            /**
             * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.
             * /!\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this
             *     target, do not update the modal via <swal> \@Inputs while the modal is open, or you'll get an error.
             *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and
             *     performance of everyone, for a relatively rare use case.
             */
            this.actions = {
                element: (/**
                 * @param {?} swal
                 * @return {?}
                 */
                function (swal) { return swal.getActions(); }),
                // The button will never exist, but SweetAlert2 shows the actions block only if there is at least one button.
                options: { showConfirmButton: true }
            };
            /**
             * Targets the confirm button contents, replacing the text inside it (not the button itself)
             */
            this.confirmButton = {
                element: (/**
                 * @param {?} swal
                 * @return {?}
                 */
                function (swal) { return swal.getConfirmButton(); }),
                options: { showConfirmButton: true }
            };
            /**
             * Targets the cancel button contents, replacing the text inside it (not the button itself)
             */
            this.cancelButton = {
                element: (/**
                 * @param {?} swal
                 * @return {?}
                 */
                function (swal) { return swal.getCancelButton(); }),
                options: { showCancelButton: true }
            };
            /**
             * Targets the modal footer contents.
             */
            this.footer = {
                element: (/**
                 * @param {?} swal
                 * @return {?}
                 */
                function (swal) { return swal.getFooter(); }),
                // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
                options: { footer: ' ' }
            };
        }
        SwalPortalTargets.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */ SwalPortalTargets.ngInjectableDef = core.defineInjectable({ factory: function SwalPortalTargets_Factory() { return new SwalPortalTargets(); }, token: SwalPortalTargets, providedIn: "root" });
        return SwalPortalTargets;
    }());
    if (false) {
        /**
         * Targets the modal close button block contents.
         * @type {?}
         */
        SwalPortalTargets.prototype.closeButton;
        /**
         * Targets the modal title block contents.
         * @type {?}
         */
        SwalPortalTargets.prototype.title;
        /**
         * Targets the modal text block contents (that is another block inside the first content block, so you can still
         * use other modal features like Swal inputs, that are situated inside that parent content block).
         * @type {?}
         */
        SwalPortalTargets.prototype.content;
        /**
         * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.
         * /!\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this
         *     target, do not update the modal via <swal> \@Inputs while the modal is open, or you'll get an error.
         *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and
         *     performance of everyone, for a relatively rare use case.
         * @type {?}
         */
        SwalPortalTargets.prototype.actions;
        /**
         * Targets the confirm button contents, replacing the text inside it (not the button itself)
         * @type {?}
         */
        SwalPortalTargets.prototype.confirmButton;
        /**
         * Targets the cancel button contents, replacing the text inside it (not the button itself)
         * @type {?}
         */
        SwalPortalTargets.prototype.cancelButton;
        /**
         * Targets the modal footer contents.
         * @type {?}
         */
        SwalPortalTargets.prototype.footer;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/swal-portal.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@internal
     * Holds a consumer's Angular template and displays it on a Sweet Alert.
     * See SwalPortalDirective for info about the covered feature.
     */
    var SwalPortalComponent = /** @class */ (function () {
        function SwalPortalComponent() {
            this.template = null;
        }
        SwalPortalComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'swal-portal',
                        template: '<ng-container *ngTemplateOutlet="template"></ng-container>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        SwalPortalComponent.propDecorators = {
            template: [{ type: core.Input }]
        };
        return SwalPortalComponent;
    }());
    if (false) {
        /** @type {?} */
        SwalPortalComponent.prototype.template;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/swal-portal.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A structural directive that lets you use Angular templates inside of SweetAlerts.
     * There are different targetable zones provided by {\@link SwalPortalTargets}: title, content, confirmButton, etc, but
     * you can also make your own target by implementing {\@link SwalPortalTarget} and giving it to this directive.
     * The default target is the alert text content zone.
     *
     * Usage in your component's TypeScript (if you use another target than {\@link SwalPortalTargets.content}):
     *
     * \@Component({ ... })
     *     export class MyComponent {
     *         public constructor(public readonly swalTargets: SwalPortalTargets) {
     *         }
     *     }
     *
     * Usage in the template:
     *
     *     <swal title="Fill the form" (confirm)="confirmHandler()">
     *         <!-- This form will be displayed as the alert main content
     *              Targets the alert's main content zone by default -->
     *         <form *swalPortal [formControl]="myForm">
     *             ...
     *         </form>
     *
     *         <!-- This targets the confirm button's inner content
     *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->
     *         <ng-container *swalPortal="swalTargets.confirmButton">
     *              Send ({{ secondsLeft }} seconds left)
     *         </ng-container>
     *     <swal>
     */
    var SwalPortalDirective = /** @class */ (function () {
        function SwalPortalDirective(resolver, injector, app, templateRef, sweetAlert2Loader, swalTargets, swalComponent) {
            this.resolver = resolver;
            this.injector = injector;
            this.app = app;
            this.templateRef = templateRef;
            this.sweetAlert2Loader = sweetAlert2Loader;
            this.swalTargets = swalTargets;
            this.swalComponent = swalComponent;
            this.destroyed = new rxjs.Subject();
        }
        /**
         * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
         * that will receive the consumer's template.
         */
        /**
         * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
         * that will receive the consumer's template.
         * @return {?}
         */
        SwalPortalDirective.prototype.ngOnInit = /**
         * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
         * that will receive the consumer's template.
         * @return {?}
         */
        function () {
            // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.
            this.target = this.target || this.swalTargets.content;
            //=> Apply the options provided by the target definition
            void this.swalComponent.update(this.target.options);
            //=> Subscribe to a few hooks frm the parent SwalComponent.
            this.swalComponent.render.pipe(operators.takeUntil(this.destroyed)).subscribe(this.renderHook.bind(this));
            this.swalComponent.beforeOpen.pipe(operators.takeUntil(this.destroyed)).subscribe(this.beforeOpenHook.bind(this));
            this.swalComponent.afterClose.pipe(operators.takeUntil(this.destroyed)).subscribe(this.afterCloseHook.bind(this));
        };
        /**
         * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the
         * parent SwalComponent events.
         */
        /**
         * Signal any {\@link destroyed} consumer that this is over, so they can unsubscribe from the
         * parent SwalComponent events.
         * @return {?}
         */
        SwalPortalDirective.prototype.ngOnDestroy = /**
         * Signal any {\@link destroyed} consumer that this is over, so they can unsubscribe from the
         * parent SwalComponent events.
         * @return {?}
         */
        function () {
            this.destroyed.next();
        };
        /**
         * This render hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
         * {@link beforeOpenHook}), or after Swal.update() is called.
         * This is a good place to render, or re-render, our portal contents.
         */
        /**
         * This render hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
         * {\@link beforeOpenHook}), or after Swal.update() is called.
         * This is a good place to render, or re-render, our portal contents.
         * @private
         * @return {?}
         */
        SwalPortalDirective.prototype.renderHook = /**
         * This render hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
         * {\@link beforeOpenHook}), or after Swal.update() is called.
         * This is a good place to render, or re-render, our portal contents.
         * @private
         * @return {?}
         */
        function () {
            return __awaiter(this, void 0, void 0, function () {
                var swal, targetEl;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            //=> Ensure the portal component is created
                            if (!this.portalComponentRef) {
                                this.portalComponentRef = this.createPortalComponent();
                            }
                            //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.
                            // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside
                            // this function is already resolved at this point), so the whole process of re-rendering and re-mounting
                            // the portal component is fully synchronous, causing no blinks in the modal contents.
                            return [4 /*yield*/, this.sweetAlert2Loader.swal];
                        case 1:
                            swal = _a.sent();
                            //=> Find target element
                            targetEl = (/** @type {?} */ (this.target)).element(swal);
                            //=> Replace target's contents with our component
                            // https://jsperf.com/innerhtml-vs-removechild/15
                            while (targetEl.firstChild) {
                                targetEl.removeChild(targetEl.firstChild);
                            }
                            targetEl.appendChild(this.portalComponentRef.location.nativeElement);
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * This beforeOpen hook runs once (per modal instance), just before the modal is shown on the screen.
         * This is a good place to declare our detached view to the Angular app.
         */
        /**
         * This beforeOpen hook runs once (per modal instance), just before the modal is shown on the screen.
         * This is a good place to declare our detached view to the Angular app.
         * @private
         * @return {?}
         */
        SwalPortalDirective.prototype.beforeOpenHook = /**
         * This beforeOpen hook runs once (per modal instance), just before the modal is shown on the screen.
         * This is a good place to declare our detached view to the Angular app.
         * @private
         * @return {?}
         */
        function () {
            if (!this.portalComponentRef)
                return;
            //=> Make the Angular app aware of that detached view so rendering and change detection can happen
            this.app.attachView(this.portalComponentRef.hostView);
        };
        /**
         * This afterClose hook runs once (per modal instance), just after the modal closing animation terminated.
         * This is a good place to detach and destroy our content, that is not visible anymore.
         */
        /**
         * This afterClose hook runs once (per modal instance), just after the modal closing animation terminated.
         * This is a good place to detach and destroy our content, that is not visible anymore.
         * @private
         * @return {?}
         */
        SwalPortalDirective.prototype.afterCloseHook = /**
         * This afterClose hook runs once (per modal instance), just after the modal closing animation terminated.
         * This is a good place to detach and destroy our content, that is not visible anymore.
         * @private
         * @return {?}
         */
        function () {
            if (!this.portalComponentRef)
                return;
            //=> Detach the portal component from the app and destroy it
            this.app.detachView(this.portalComponentRef.hostView);
            this.portalComponentRef.destroy();
            this.portalComponentRef = void 0;
        };
        /**
         * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.
         */
        /**
         * Creates the {\@link SwalPortalComponent} and gives it the customer's template ref.
         * @private
         * @return {?}
         */
        SwalPortalDirective.prototype.createPortalComponent = /**
         * Creates the {\@link SwalPortalComponent} and gives it the customer's template ref.
         * @private
         * @return {?}
         */
        function () {
            //=> Create the SwalPortalComponent that will hold our content
            /** @type {?} */
            var factory = this.resolver.resolveComponentFactory(SwalPortalComponent);
            // Yes, we do not use the third argument that would directly use the target as the component's view
            // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)
            // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be
            // able to restore it at any moment, ie. after the modal has been re-rendered.
            /** @type {?} */
            var componentRef = factory.create(this.injector, []);
            //=> Apply the consumer's template on the component
            componentRef.instance.template = this.templateRef;
            return componentRef;
        };
        SwalPortalDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[swalPortal]'
                    },] }
        ];
        /** @nocollapse */
        SwalPortalDirective.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver },
            { type: core.Injector },
            { type: core.ApplicationRef },
            { type: core.TemplateRef },
            { type: SweetAlert2LoaderService },
            { type: SwalPortalTargets },
            { type: SwalComponent, decorators: [{ type: core.Host }] }
        ]; };
        SwalPortalDirective.propDecorators = {
            target: [{ type: core.Input, args: ['swalPortal',] }]
        };
        return SwalPortalDirective;
    }());
    if (false) {
        /**
         * Takes a portal target or nothing (then it will target the text content zone by default).
         *
         * See the {\@link SwalPortalTargets} service to see the available targets.
         * See the class doc block for more informations.
         * @type {?}
         */
        SwalPortalDirective.prototype.target;
        /**
         * Holds the component reference of the controlled SwalPortalComponent to destroy it when no longer needed.
         * @type {?}
         * @private
         */
        SwalPortalDirective.prototype.portalComponentRef;
        /**
         * @type {?}
         * @private
         */
        SwalPortalDirective.prototype.destroyed;
        /**
         * @type {?}
         * @private
         */
        SwalPortalDirective.prototype.resolver;
        /**
         * @type {?}
         * @private
         */
        SwalPortalDirective.prototype.injector;
        /**
         * @type {?}
         * @private
         */
        SwalPortalDirective.prototype.app;
        /**
         * @type {?}
         * @private
         */
        SwalPortalDirective.prototype.templateRef;
        /**
         * @type {?}
         * @private
         */
        SwalPortalDirective.prototype.sweetAlert2Loader;
        /**
         * @type {?}
         * @private
         */
        SwalPortalDirective.prototype.swalTargets;
        /**
         * @type {?}
         * @private
         */
        SwalPortalDirective.prototype.swalComponent;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sweetalert2.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function Sweetalert2ModuleConfig() { }
    if (false) {
        /** @type {?|undefined} */
        Sweetalert2ModuleConfig.prototype.provideSwal;
        /** @type {?|undefined} */
        Sweetalert2ModuleConfig.prototype.fireOnInit;
        /** @type {?|undefined} */
        Sweetalert2ModuleConfig.prototype.dismissOnDestroy;
    }
    /**
     * @return {?}
     */
    function provideDefaultSwal() {
        return import('sweetalert2');
    }
    var SweetAlert2Module = /** @class */ (function () {
        function SweetAlert2Module() {
        }
        /**
         * @param {?=} options
         * @return {?}
         */
        SweetAlert2Module.forRoot = /**
         * @param {?=} options
         * @return {?}
         */
        function (options) {
            if (options === void 0) { options = {}; }
            return {
                ngModule: SweetAlert2Module,
                providers: [
                    SweetAlert2LoaderService,
                    { provide: swalProviderToken, useValue: options.provideSwal || provideDefaultSwal },
                    { provide: fireOnInitToken, useValue: options.fireOnInit || false },
                    { provide: dismissOnDestroyToken, useValue: options.dismissOnDestroy || true }
                ]
            };
        };
        /**
         * @param {?=} options
         * @return {?}
         */
        SweetAlert2Module.forChild = /**
         * @param {?=} options
         * @return {?}
         */
        function (options) {
            if (options === void 0) { options = {}; }
            return {
                ngModule: SweetAlert2Module,
                providers: __spread(options.provideSwal ? [
                    SweetAlert2LoaderService,
                    { provide: swalProviderToken, useValue: options.provideSwal }
                ] : [], options.fireOnInit !== undefined ? [
                    { provide: fireOnInitToken, useValue: options.fireOnInit }
                ] : [], options.dismissOnDestroy !== undefined ? [
                    { provide: dismissOnDestroyToken, useValue: options.dismissOnDestroy }
                ] : [])
            };
        };
        SweetAlert2Module.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            SwalDirective, SwalComponent, SwalPortalDirective, SwalPortalComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            SwalComponent, SwalPortalDirective, SwalDirective
                        ],
                        entryComponents: [
                            SwalComponent, SwalPortalComponent
                        ]
                    },] }
        ];
        return SweetAlert2Module;
    }());

    exports.SwalComponent = SwalComponent;
    exports.SwalDirective = SwalDirective;
    exports.SwalPortalTargets = SwalPortalTargets;
    exports.SweetAlert2LoaderService = SweetAlert2LoaderService;
    exports.SweetAlert2Module = SweetAlert2Module;
    exports.a = provideDefaultSwal;
    exports.b = swalProviderToken;
    exports.c = fireOnInitToken;
    exports.d = dismissOnDestroyToken;
    exports.e = SwalPortalDirective;
    exports.f = SwalPortalComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=sweetalert2-ngx-sweetalert2.umd.js.map
