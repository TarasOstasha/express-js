import { __awaiter, __generator, __assign, __read, __spread } from 'tslib';
import { InjectionToken, Injectable, Inject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, Directive, ViewContainerRef, ComponentFactoryResolver, HostListener, ɵɵdefineInjectable, Injector, ApplicationRef, TemplateRef, Host, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/di.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var swalProviderToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#swalProvider');
/** @type {?} */
var fireOnInitToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#fireOnInit');
/** @type {?} */
var dismissOnDestroyToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#dismissOnDestroy');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/sweetalert2-loader.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SweetAlert2LoaderService = /** @class */ (function () {
    // Using any because Angular metadata generator does not understand a pure TS type here
    function SweetAlert2LoaderService(swalProvider) {
        this.swalProvider = swalProvider;
    }
    Object.defineProperty(SweetAlert2LoaderService.prototype, "swal", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.swalPromiseCache) {
                this.preloadSweetAlertLibrary();
            }
            return (/** @type {?} */ (this.swalPromiseCache));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SweetAlert2LoaderService.prototype.preloadSweetAlertLibrary = /**
     * @return {?}
     */
    function () {
        if (this.swalPromiseCache)
            return;
        /** @type {?} */
        var libPromise = isLoader(this.swalProvider)
            ? this.swalProvider()
            : Promise.resolve(this.swalProvider);
        this.swalPromiseCache = libPromise.then((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return isDefaultExport(value) ? value : value.default; }));
        /**
         * @param {?} value
         * @return {?}
         */
        function isLoader(value) {
            return typeof value === 'function' && ((/** @type {?} */ (value))).version === undefined;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        function isDefaultExport(value) {
            return typeof value === 'function';
        }
    };
    SweetAlert2LoaderService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    SweetAlert2LoaderService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [swalProviderToken,] }] }
    ]; };
    return SweetAlert2LoaderService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    SweetAlert2LoaderService.prototype.swalProvider;
    /**
     * @type {?}
     * @private
     */
    SweetAlert2LoaderService.prototype.swalPromiseCache;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/swal.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of \@Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many \@Inputs,
 *     take a look at [swalOptions], that lets you pass a full {\@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't \@Inputs but \@Outputs: onBeforeOpen, onOpen, onClose and onAfterClose
 *     (but without "on*" prefix to respect community standards).
 *     However, preConfirm and inputValidator are still \@Inputs because there are not event handlers, there can't be
 *     multiple listeners and we need the values they can/must return.
 */
var SwalComponent = /** @class */ (function () {
    function SwalComponent(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.moduleLevelFireOnInit = moduleLevelFireOnInit;
        this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
        /**
         * Emits an event when the modal DOM element has been created.
         * Useful to perform DOM mutations before the modal is shown.
         */
        this.beforeOpen = new EventEmitter();
        /**
         * Emits an event when the modal is shown.
         */
        this.open = new EventEmitter();
        /**
         * Emits an event when the modal DOM is rendered.
         */
        this.render = new EventEmitter();
        /**
         * Emits an event when the modal will be closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.close = new EventEmitter();
        /**
         * Emits an event after the modal had been closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
         * The reason is `undefined` when {\@link dismiss} is called.
         *
         * Example:
         *     <swal (cancel)="handleCancel($event)"></swal>
         *
         *     public handleCancel(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
        /**
         * This Set retains the properties that have been changed from \@Inputs, so we can know precisely
         * what options we have to send to {\@link Swal.fire}.
         */
        this.touchedProps = new Set();
        /**
         * A function of signature `(propName: string): void` that adds a given property name to the list of
         * touched properties, ie. {\@link touchedProps}.
         */
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        /**
         * Is the SweetAlert2 modal represented by this component currently opened?
         */
        this.isCurrentlyShown = false;
    }
    Object.defineProperty(SwalComponent.prototype, "swalOptions", {
        /**
         * Computes the options object that will get passed to SweetAlert2.
         * Only the properties that have been set at least once on this component will be returned.
         * Mostly for internal usage.
         */
        get: /**
         * Computes the options object that will get passed to SweetAlert2.
         * Only the properties that have been set at least once on this component will be returned.
         * Mostly for internal usage.
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var options = {};
            //=> We will compute the options object based on the option keys that are known to have changed.
            //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
            //   avoiding side effects.
            this.touchedProps.forEach((/**
             * @param {?} prop
             * @return {?}
             */
            function (prop) {
                options[prop] = _this[(/** @type {?} */ (prop))];
            }));
            return options;
        },
        /**
         * An object of SweetAlert2 native options, useful if:
         *  - you don't want to use the @Inputs for practical/philosophical reasons ;
         *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
         *
         * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
         *     previous properties you want to erase again.
         *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
         *
         * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
         */
        set: /**
         * An object of SweetAlert2 native options, useful if:
         *  - you don't want to use the \@Inputs for practical/philosophical reasons ;
         *  - there are missing \@Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
         *
         * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
         *     previous properties you want to erase again.
         *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
         *
         * /!\ Be aware that the options defined in this object will override the \@Inputs of the same name.
         * @param {?} options
         * @return {?}
         */
        function (options) {
            //=> Update properties
            Object.assign(this, options);
            //=> Mark changed properties as touched
            /** @type {?} */
            var touchedKeys = (/** @type {?} */ (Object.keys(options)));
            touchedKeys.forEach(this.markTouched);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwalComponent.prototype, "swalVisible", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isCurrentlyShown;
        },
        set: /**
         * @param {?} visible
         * @return {?}
         */
        function (visible) {
            visible ? this.fire() : this.dismiss();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     */
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     * @return {?}
     */
    SwalComponent.prototype.ngOnInit = /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     * @return {?}
     */
    function () {
        //=> Preload SweetAlert2 library in case this component is activated.
        this.sweetAlert2Loader.preloadSweetAlertLibrary();
    };
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     */
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     * @return {?}
     */
    SwalComponent.prototype.ngAfterViewInit = /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var fireOnInit = this.swalFireOnInit === undefined
            ? this.moduleLevelFireOnInit
            : this.swalFireOnInit;
        fireOnInit && this.fire();
    };
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     */
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     * @param {?} changes
     * @return {?}
     */
    SwalComponent.prototype.ngOnChanges = /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
        //   send it with the next fire() or update() calls.
        Object.keys(changes)
            //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
            .filter((/**
         * @param {?} prop
         * @return {?}
         */
        function (prop) { return !prop.startsWith('swal'); }))
            .forEach(this.markTouched);
        //=> Eventually trigger re-render if the modal is open.
        void this.update();
    };
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     */
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     * @return {?}
     */
    SwalComponent.prototype.ngOnDestroy = /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     * @return {?}
     */
    function () {
        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
        /** @type {?} */
        var dismissOnDestroy = this.swalDismissOnDestroy === undefined
            ? this.moduleLevelDismissOnDestroy
            : this.swalDismissOnDestroy;
        dismissOnDestroy && this.dismiss();
    };
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     */
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     * @return {?}
     */
    SwalComponent.prototype.fire = /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var swal, options, result;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.sweetAlert2Loader.swal];
                    case 1:
                        swal = _a.sent();
                        //=> Build the SweetAlert2 options
                        options = __assign({}, this.swalOptions, { onBeforeOpen: (/**
                             * @param {?} modalElement
                             * @return {?}
                             */
                            function (modalElement) {
                                _this.beforeOpen.emit({ modalElement: modalElement });
                            }), onOpen: (/**
                             * @param {?} modalElement
                             * @return {?}
                             */
                            function (modalElement) {
                                _this.isCurrentlyShown = true;
                                _this.open.emit({ modalElement: modalElement });
                            }), onRender: (/**
                             * @param {?} modalElement
                             * @return {?}
                             */
                            function (modalElement) {
                                _this.render.emit({ modalElement: modalElement });
                            }), onClose: (/**
                             * @param {?} modalElement
                             * @return {?}
                             */
                            function (modalElement) {
                                _this.isCurrentlyShown = false;
                                _this.close.emit({ modalElement: modalElement });
                            }), onAfterClose: (/**
                             * @return {?}
                             */
                            function () {
                                _this.afterClose.emit();
                            }) });
                        //=> Show the Swal! And wait for confirmation or dimissal.
                        return [4 /*yield*/, swal.fire(options)];
                    case 2:
                        result = _a.sent();
                        //=> Emit on (confirm) or (cancel)
                        if ('value' in result) {
                            this.confirm.emit(result.value);
                        }
                        else {
                            this.cancel.emit(result.dismiss);
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Closes the modal, if opened.
     *
     * @param result The value that the modal will resolve with, triggering either (confirm) or (cancel).
     *               If the argument is not passed, (dimiss) will emit `undefined`.
     *               See {@link Swal.close}
     */
    /**
     * Closes the modal, if opened.
     *
     * @param {?=} result The value that the modal will resolve with, triggering either (confirm) or (cancel).
     *               If the argument is not passed, (dimiss) will emit `undefined`.
     *               See {\@link Swal.close}
     * @return {?}
     */
    SwalComponent.prototype.dismiss = /**
     * Closes the modal, if opened.
     *
     * @param {?=} result The value that the modal will resolve with, triggering either (confirm) or (cancel).
     *               If the argument is not passed, (dimiss) will emit `undefined`.
     *               See {\@link Swal.close}
     * @return {?}
     */
    function (result) {
        return __awaiter(this, void 0, void 0, function () {
            var swal;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.isCurrentlyShown)
                            return [2 /*return*/];
                        return [4 /*yield*/, this.sweetAlert2Loader.swal];
                    case 1:
                        swal = _a.sent();
                        swal.close(result);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param options
     */
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param {?=} options
     * @return {?}
     */
    SwalComponent.prototype.update = /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var swal, allOptions, updatableOptions;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (options) {
                            this.swalOptions = options;
                        }
                        if (!this.isCurrentlyShown)
                            return [2 /*return*/];
                        return [4 /*yield*/, this.sweetAlert2Loader.swal];
                    case 1:
                        swal = _a.sent();
                        allOptions = this.swalOptions;
                        updatableOptions = Object.keys(allOptions)
                            .filter((/**
                         * @param {?} key
                         * @return {?}
                         */
                        function (key) { return swal.isUpdatableParameter(key); }))
                            .reduce((/**
                         * @param {?} obj
                         * @param {?} key
                         * @return {?}
                         */
                        function (obj, key) {
                            obj[key] = allOptions[key];
                            return obj;
                        }), (/** @type {?} */ ({})));
                        swal.update(updatableOptions);
                        return [2 /*return*/];
                }
            });
        });
    };
    SwalComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'swal',
                    template: '',
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    SwalComponent.ctorParameters = function () { return [
        { type: SweetAlert2LoaderService },
        { type: Boolean, decorators: [{ type: Inject, args: [fireOnInitToken,] }] },
        { type: Boolean, decorators: [{ type: Inject, args: [dismissOnDestroyToken,] }] }
    ]; };
    SwalComponent.propDecorators = {
        title: [{ type: Input }],
        titleText: [{ type: Input }],
        text: [{ type: Input }],
        html: [{ type: Input }],
        footer: [{ type: Input }],
        icon: [{ type: Input }],
        iconHtml: [{ type: Input }],
        backdrop: [{ type: Input }],
        toast: [{ type: Input }],
        target: [{ type: Input }],
        input: [{ type: Input }],
        width: [{ type: Input }],
        padding: [{ type: Input }],
        background: [{ type: Input }],
        position: [{ type: Input }],
        grow: [{ type: Input }],
        showClass: [{ type: Input }],
        hideClass: [{ type: Input }],
        customClass: [{ type: Input }],
        timer: [{ type: Input }],
        animation: [{ type: Input }],
        heightAuto: [{ type: Input }],
        allowOutsideClick: [{ type: Input }],
        allowEscapeKey: [{ type: Input }],
        allowEnterKey: [{ type: Input }],
        stopKeydownPropagation: [{ type: Input }],
        keydownListenerCapture: [{ type: Input }],
        showConfirmButton: [{ type: Input }],
        showCancelButton: [{ type: Input }],
        confirmButtonText: [{ type: Input }],
        cancelButtonText: [{ type: Input }],
        confirmButtonColor: [{ type: Input }],
        cancelButtonColor: [{ type: Input }],
        confirmButtonAriaLabel: [{ type: Input }],
        cancelButtonAriaLabel: [{ type: Input }],
        buttonsStyling: [{ type: Input }],
        reverseButtons: [{ type: Input }],
        focusConfirm: [{ type: Input }],
        focusCancel: [{ type: Input }],
        showCloseButton: [{ type: Input }],
        closeButtonHtml: [{ type: Input }],
        closeButtonAriaLabel: [{ type: Input }],
        showLoaderOnConfirm: [{ type: Input }],
        preConfirm: [{ type: Input }],
        imageUrl: [{ type: Input }],
        imageWidth: [{ type: Input }],
        imageHeight: [{ type: Input }],
        imageAlt: [{ type: Input }],
        inputPlaceholder: [{ type: Input }],
        inputValue: [{ type: Input }],
        inputOptions: [{ type: Input }],
        inputAutoTrim: [{ type: Input }],
        inputAttributes: [{ type: Input }],
        inputValidator: [{ type: Input }],
        validationMessage: [{ type: Input }],
        progressSteps: [{ type: Input }],
        currentProgressStep: [{ type: Input }],
        progressStepsDistance: [{ type: Input }],
        scrollbarPadding: [{ type: Input }],
        swalOptions: [{ type: Input }],
        swalFireOnInit: [{ type: Input }],
        swalDismissOnDestroy: [{ type: Input }],
        swalVisible: [{ type: Input }],
        beforeOpen: [{ type: Output }],
        open: [{ type: Output }],
        render: [{ type: Output }],
        close: [{ type: Output }],
        afterClose: [{ type: Output }],
        confirm: [{ type: Output }],
        cancel: [{ type: Output }]
    };
    return SwalComponent;
}());
if (false) {
    /** @type {?} */
    SwalComponent.prototype.title;
    /** @type {?} */
    SwalComponent.prototype.titleText;
    /** @type {?} */
    SwalComponent.prototype.text;
    /** @type {?} */
    SwalComponent.prototype.html;
    /** @type {?} */
    SwalComponent.prototype.footer;
    /** @type {?} */
    SwalComponent.prototype.icon;
    /** @type {?} */
    SwalComponent.prototype.iconHtml;
    /** @type {?} */
    SwalComponent.prototype.backdrop;
    /** @type {?} */
    SwalComponent.prototype.toast;
    /** @type {?} */
    SwalComponent.prototype.target;
    /** @type {?} */
    SwalComponent.prototype.input;
    /** @type {?} */
    SwalComponent.prototype.width;
    /** @type {?} */
    SwalComponent.prototype.padding;
    /** @type {?} */
    SwalComponent.prototype.background;
    /** @type {?} */
    SwalComponent.prototype.position;
    /** @type {?} */
    SwalComponent.prototype.grow;
    /** @type {?} */
    SwalComponent.prototype.showClass;
    /** @type {?} */
    SwalComponent.prototype.hideClass;
    /** @type {?} */
    SwalComponent.prototype.customClass;
    /** @type {?} */
    SwalComponent.prototype.timer;
    /**
     * @deprecated Use showClass and hideClass instead
     * @type {?}
     */
    SwalComponent.prototype.animation;
    /** @type {?} */
    SwalComponent.prototype.heightAuto;
    /** @type {?} */
    SwalComponent.prototype.allowOutsideClick;
    /** @type {?} */
    SwalComponent.prototype.allowEscapeKey;
    /** @type {?} */
    SwalComponent.prototype.allowEnterKey;
    /** @type {?} */
    SwalComponent.prototype.stopKeydownPropagation;
    /** @type {?} */
    SwalComponent.prototype.keydownListenerCapture;
    /** @type {?} */
    SwalComponent.prototype.showConfirmButton;
    /** @type {?} */
    SwalComponent.prototype.showCancelButton;
    /** @type {?} */
    SwalComponent.prototype.confirmButtonText;
    /** @type {?} */
    SwalComponent.prototype.cancelButtonText;
    /** @type {?} */
    SwalComponent.prototype.confirmButtonColor;
    /** @type {?} */
    SwalComponent.prototype.cancelButtonColor;
    /** @type {?} */
    SwalComponent.prototype.confirmButtonAriaLabel;
    /** @type {?} */
    SwalComponent.prototype.cancelButtonAriaLabel;
    /** @type {?} */
    SwalComponent.prototype.buttonsStyling;
    /** @type {?} */
    SwalComponent.prototype.reverseButtons;
    /** @type {?} */
    SwalComponent.prototype.focusConfirm;
    /** @type {?} */
    SwalComponent.prototype.focusCancel;
    /** @type {?} */
    SwalComponent.prototype.showCloseButton;
    /** @type {?} */
    SwalComponent.prototype.closeButtonHtml;
    /** @type {?} */
    SwalComponent.prototype.closeButtonAriaLabel;
    /** @type {?} */
    SwalComponent.prototype.showLoaderOnConfirm;
    /** @type {?} */
    SwalComponent.prototype.preConfirm;
    /** @type {?} */
    SwalComponent.prototype.imageUrl;
    /** @type {?} */
    SwalComponent.prototype.imageWidth;
    /** @type {?} */
    SwalComponent.prototype.imageHeight;
    /** @type {?} */
    SwalComponent.prototype.imageAlt;
    /** @type {?} */
    SwalComponent.prototype.inputPlaceholder;
    /** @type {?} */
    SwalComponent.prototype.inputValue;
    /** @type {?} */
    SwalComponent.prototype.inputOptions;
    /** @type {?} */
    SwalComponent.prototype.inputAutoTrim;
    /** @type {?} */
    SwalComponent.prototype.inputAttributes;
    /** @type {?} */
    SwalComponent.prototype.inputValidator;
    /** @type {?} */
    SwalComponent.prototype.validationMessage;
    /** @type {?} */
    SwalComponent.prototype.progressSteps;
    /** @type {?} */
    SwalComponent.prototype.currentProgressStep;
    /** @type {?} */
    SwalComponent.prototype.progressStepsDistance;
    /** @type {?} */
    SwalComponent.prototype.scrollbarPadding;
    /**
     * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.
     * When left undefined (default), the value will be inherited from the module configuration, which is `false`.
     *
     * Example:
     *     <swal *ngIf="error" [title]="error.title" [text]="error.text" icon="error" [swalFireOnInit]="true"></swal>
     * @type {?}
     */
    SwalComponent.prototype.swalFireOnInit;
    /**
     * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.
     * When left undefined (default), the value will be inherited from the module configuration, which is `true`.
     * @type {?}
     */
    SwalComponent.prototype.swalDismissOnDestroy;
    /**
     * Emits an event when the modal DOM element has been created.
     * Useful to perform DOM mutations before the modal is shown.
     * @type {?}
     */
    SwalComponent.prototype.beforeOpen;
    /**
     * Emits an event when the modal is shown.
     * @type {?}
     */
    SwalComponent.prototype.open;
    /**
     * Emits an event when the modal DOM is rendered.
     * @type {?}
     */
    SwalComponent.prototype.render;
    /**
     * Emits an event when the modal will be closed.
     * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
     * @type {?}
     */
    SwalComponent.prototype.close;
    /**
     * Emits an event after the modal had been closed.
     * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
     * @type {?}
     */
    SwalComponent.prototype.afterClose;
    /**
     * Emits when the user clicks "Confirm".
     * Bears a value when using "input", resolved "preConfirm", etc.
     *
     * Example:
     *     <swal (confirm)="handleConfirm($event)"></swal>
     *
     *     public handleConfirm(email: string): void {
     *         // ... save user email
     *     }
     * @type {?}
     */
    SwalComponent.prototype.confirm;
    /**
     * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
     * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
     * The reason is `undefined` when {\@link dismiss} is called.
     *
     * Example:
     *     <swal (cancel)="handleCancel($event)"></swal>
     *
     *     public handleCancel(reason: DismissReason | undefined): void {
     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
     *         // ... do something
     *     }
     * @type {?}
     */
    SwalComponent.prototype.cancel;
    /**
     * This Set retains the properties that have been changed from \@Inputs, so we can know precisely
     * what options we have to send to {\@link Swal.fire}.
     * @type {?}
     * @private
     */
    SwalComponent.prototype.touchedProps;
    /**
     * A function of signature `(propName: string): void` that adds a given property name to the list of
     * touched properties, ie. {\@link touchedProps}.
     * @type {?}
     * @private
     */
    SwalComponent.prototype.markTouched;
    /**
     * Is the SweetAlert2 modal represented by this component currently opened?
     * @type {?}
     * @private
     */
    SwalComponent.prototype.isCurrentlyShown;
    /**
     * @type {?}
     * @private
     */
    SwalComponent.prototype.sweetAlert2Loader;
    /**
     * @type {?}
     * @private
     */
    SwalComponent.prototype.moduleLevelFireOnInit;
    /**
     * @type {?}
     * @private
     */
    SwalComponent.prototype.moduleLevelDismissOnDestroy;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/swal.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * [swal] directive. It takes a value that defines the SweetAlert and can be of three types:
 *
 * 1) A simple array of two or three strings defining [title, text, icon] - the icon being optional, ex:
 *
 *    <button [swal]="['Title', 'Text']">Click me</button>
 *
 * 2) A native SweetAlert2 options object, ex:
 *
 *    <button [swal]="{ title: 'Title', text: 'Text' }">Click me</button>
 *
 * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:
 *
 *    <button [swal]="mySwal">Click me</button>
 *    <swal #mySwal title="Title" text="Text"></swal>
 */
var SwalDirective = /** @class */ (function () {
    function SwalDirective(viewContainerRef, resolver) {
        this.viewContainerRef = viewContainerRef;
        this.resolver = resolver;
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
         * The reason is `undefined` when {\@link dismiss} is called.
         *
         * Example:
         *     <swal (cancel)="handleCancel($event)"></swal>
         *
         *     public handleCancel(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
    }
    Object.defineProperty(SwalDirective.prototype, "swal", {
        /**
         * SweetAlert2 options or a SwalComponent instance.
         * See the class doc block for more informations.
         */
        set: /**
         * SweetAlert2 options or a SwalComponent instance.
         * See the class doc block for more informations.
         * @param {?} options
         * @return {?}
         */
        function (options) {
            var _a;
            if (options instanceof SwalComponent) {
                this.swalInstance = options;
            }
            else if (Array.isArray(options)) {
                this.swalOptions = {};
                _a = __read(options, 3), this.swalOptions.title = _a[0], this.swalOptions.text = _a[1], this.swalOptions.icon = _a[2];
            }
            else {
                this.swalOptions = options;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     */
    /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     * @return {?}
     */
    SwalDirective.prototype.ngOnInit = /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     * @return {?}
     */
    function () {
        if (!this.swalInstance) {
            /** @type {?} */
            var factory = this.resolver.resolveComponentFactory(SwalComponent);
            this.swalRef = this.viewContainerRef.createComponent(factory);
            this.swalInstance = this.swalRef.instance;
        }
    };
    /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent.
     */
    /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent.
     * @return {?}
     */
    SwalDirective.prototype.ngOnDestroy = /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent.
     * @return {?}
     */
    function () {
        if (this.swalRef) {
            this.swalRef.destroy();
        }
    };
    /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     */
    /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     * @param {?} event
     * @return {?}
     */
    SwalDirective.prototype.onClick = /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        event.preventDefault();
        event.stopImmediatePropagation();
        event.stopPropagation();
        if (!this.swalInstance)
            return;
        if (this.swalOptions) {
            this.swalInstance.swalOptions = this.swalOptions;
        }
        /** @type {?} */
        var swalClosed = new Subject();
        this.swalInstance.confirm.asObservable().pipe(takeUntil(swalClosed)).subscribe((/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return _this.confirm.emit(v); }));
        this.swalInstance.cancel.asObservable().pipe(takeUntil(swalClosed)).subscribe((/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return _this.cancel.emit(v); }));
        this.swalInstance.fire().then((/**
         * @return {?}
         */
        function () { return swalClosed.next(); }));
    };
    SwalDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[swal]'
                },] }
    ];
    /** @nocollapse */
    SwalDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: ComponentFactoryResolver }
    ]; };
    SwalDirective.propDecorators = {
        swal: [{ type: Input }],
        confirm: [{ type: Output }],
        cancel: [{ type: Output }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return SwalDirective;
}());
if (false) {
    /**
     * Emits when the user clicks "Confirm".
     * Bears a value when using "input", resolved "preConfirm", etc.
     *
     * Example:
     *     <swal (confirm)="handleConfirm($event)"></swal>
     *
     *     public handleConfirm(email: string): void {
     *         // ... save user email
     *     }
     * @type {?}
     */
    SwalDirective.prototype.confirm;
    /**
     * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
     * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
     * The reason is `undefined` when {\@link dismiss} is called.
     *
     * Example:
     *     <swal (cancel)="handleCancel($event)"></swal>
     *
     *     public handleCancel(reason: DismissReason | undefined): void {
     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
     *         // ... do something
     *     }
     * @type {?}
     */
    SwalDirective.prototype.cancel;
    /**
     * When the user does not provides a SwalComponent instance, we create it on-the-fly and assign the plain-object
     * options to it.
     * This fields keeps a reference to the dynamically-created <swal>, to destroy it along this directive instance.
     * @type {?}
     * @private
     */
    SwalDirective.prototype.swalRef;
    /**
     * An instance of the <swal> component that this directive controls.
     * Could be an instance passed by the user, otherwise it's the instance we've dynamically created.
     * @type {?}
     * @private
     */
    SwalDirective.prototype.swalInstance;
    /**
     * Holds the native SweetAlert2 options.
     * Empty when the user passed an existing SwalComponent instance.
     * @type {?}
     * @private
     */
    SwalDirective.prototype.swalOptions;
    /**
     * @type {?}
     * @private
     */
    SwalDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    SwalDirective.prototype.resolver;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/swal-events.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Emitted when a SweetAlert modal gets created in memory, just before it's displayed.
 * @record
 */
function BeforeOpenEvent() { }
if (false) {
    /** @type {?} */
    BeforeOpenEvent.prototype.modalElement;
}
/**
 * Emitted when a SweetAlert modal gets displayed.
 * @record
 */
function OpenEvent() { }
if (false) {
    /** @type {?} */
    OpenEvent.prototype.modalElement;
}
/**
 * Emitted when a SweetAlert modal gets rendered.
 * @record
 */
function RenderEvent() { }
if (false) {
    /** @type {?} */
    RenderEvent.prototype.modalElement;
}
/**
 * Emitted when a SweetAlert modal gets closed (because it's been confirmed, cancelled, or for no reason at all).
 * @record
 */
function CloseEvent() { }
if (false) {
    /** @type {?} */
    CloseEvent.prototype.modalElement;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/swal-portal-targets.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function SwalPortalTarget() { }
if (false) {
    /** @type {?|undefined} */
    SwalPortalTarget.prototype.options;
    /**
     * @param {?} swal
     * @return {?}
     */
    SwalPortalTarget.prototype.element = function (swal) { };
}
/**
 * Represents an object of targets for <swal> portals (use with *swalPortal directive).
 * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is
 * shown, so this object lets us reference those functions safely and in a statically-typed manner.
 */
var SwalPortalTargets = /** @class */ (function () {
    function SwalPortalTargets() {
        /**
         * Targets the modal close button block contents.
         */
        this.closeButton = {
            element: (/**
             * @param {?} swal
             * @return {?}
             */
            function (swal) { return swal.getCloseButton(); }),
            options: { showCloseButton: true }
        };
        /**
         * Targets the modal title block contents.
         */
        this.title = {
            element: (/**
             * @param {?} swal
             * @return {?}
             */
            function (swal) { return swal.getTitle(); }),
            // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
            options: { title: ' ' }
        };
        /**
         * Targets the modal text block contents (that is another block inside the first content block, so you can still
         * use other modal features like Swal inputs, that are situated inside that parent content block).
         */
        this.content = {
            element: (/**
             * @param {?} swal
             * @return {?}
             */
            function (swal) { return swal.getHtmlContainer(); }),
            // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
            options: { text: ' ' }
        };
        /**
         * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.
         * /!\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this
         *     target, do not update the modal via <swal> \@Inputs while the modal is open, or you'll get an error.
         *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and
         *     performance of everyone, for a relatively rare use case.
         */
        this.actions = {
            element: (/**
             * @param {?} swal
             * @return {?}
             */
            function (swal) { return swal.getActions(); }),
            // The button will never exist, but SweetAlert2 shows the actions block only if there is at least one button.
            options: { showConfirmButton: true }
        };
        /**
         * Targets the confirm button contents, replacing the text inside it (not the button itself)
         */
        this.confirmButton = {
            element: (/**
             * @param {?} swal
             * @return {?}
             */
            function (swal) { return swal.getConfirmButton(); }),
            options: { showConfirmButton: true }
        };
        /**
         * Targets the cancel button contents, replacing the text inside it (not the button itself)
         */
        this.cancelButton = {
            element: (/**
             * @param {?} swal
             * @return {?}
             */
            function (swal) { return swal.getCancelButton(); }),
            options: { showCancelButton: true }
        };
        /**
         * Targets the modal footer contents.
         */
        this.footer = {
            element: (/**
             * @param {?} swal
             * @return {?}
             */
            function (swal) { return swal.getFooter(); }),
            // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
            options: { footer: ' ' }
        };
    }
    SwalPortalTargets.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ SwalPortalTargets.ngInjectableDef = ɵɵdefineInjectable({ factory: function SwalPortalTargets_Factory() { return new SwalPortalTargets(); }, token: SwalPortalTargets, providedIn: "root" });
    return SwalPortalTargets;
}());
if (false) {
    /**
     * Targets the modal close button block contents.
     * @type {?}
     */
    SwalPortalTargets.prototype.closeButton;
    /**
     * Targets the modal title block contents.
     * @type {?}
     */
    SwalPortalTargets.prototype.title;
    /**
     * Targets the modal text block contents (that is another block inside the first content block, so you can still
     * use other modal features like Swal inputs, that are situated inside that parent content block).
     * @type {?}
     */
    SwalPortalTargets.prototype.content;
    /**
     * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.
     * /!\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this
     *     target, do not update the modal via <swal> \@Inputs while the modal is open, or you'll get an error.
     *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and
     *     performance of everyone, for a relatively rare use case.
     * @type {?}
     */
    SwalPortalTargets.prototype.actions;
    /**
     * Targets the confirm button contents, replacing the text inside it (not the button itself)
     * @type {?}
     */
    SwalPortalTargets.prototype.confirmButton;
    /**
     * Targets the cancel button contents, replacing the text inside it (not the button itself)
     * @type {?}
     */
    SwalPortalTargets.prototype.cancelButton;
    /**
     * Targets the modal footer contents.
     * @type {?}
     */
    SwalPortalTargets.prototype.footer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/swal-portal.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * Holds a consumer's Angular template and displays it on a Sweet Alert.
 * See SwalPortalDirective for info about the covered feature.
 */
var SwalPortalComponent = /** @class */ (function () {
    function SwalPortalComponent() {
        this.template = null;
    }
    SwalPortalComponent.decorators = [
        { type: Component, args: [{
                    selector: 'swal-portal',
                    template: '<ng-container *ngTemplateOutlet="template"></ng-container>',
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    SwalPortalComponent.propDecorators = {
        template: [{ type: Input }]
    };
    return SwalPortalComponent;
}());
if (false) {
    /** @type {?} */
    SwalPortalComponent.prototype.template;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/swal-portal.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A structural directive that lets you use Angular templates inside of SweetAlerts.
 * There are different targetable zones provided by {\@link SwalPortalTargets}: title, content, confirmButton, etc, but
 * you can also make your own target by implementing {\@link SwalPortalTarget} and giving it to this directive.
 * The default target is the alert text content zone.
 *
 * Usage in your component's TypeScript (if you use another target than {\@link SwalPortalTargets.content}):
 *
 * \@Component({ ... })
 *     export class MyComponent {
 *         public constructor(public readonly swalTargets: SwalPortalTargets) {
 *         }
 *     }
 *
 * Usage in the template:
 *
 *     <swal title="Fill the form" (confirm)="confirmHandler()">
 *         <!-- This form will be displayed as the alert main content
 *              Targets the alert's main content zone by default -->
 *         <form *swalPortal [formControl]="myForm">
 *             ...
 *         </form>
 *
 *         <!-- This targets the confirm button's inner content
 *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->
 *         <ng-container *swalPortal="swalTargets.confirmButton">
 *              Send ({{ secondsLeft }} seconds left)
 *         </ng-container>
 *     <swal>
 */
var SwalPortalDirective = /** @class */ (function () {
    function SwalPortalDirective(resolver, injector, app, templateRef, sweetAlert2Loader, swalTargets, swalComponent) {
        this.resolver = resolver;
        this.injector = injector;
        this.app = app;
        this.templateRef = templateRef;
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.swalTargets = swalTargets;
        this.swalComponent = swalComponent;
        this.destroyed = new Subject();
    }
    /**
     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
     * that will receive the consumer's template.
     */
    /**
     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
     * that will receive the consumer's template.
     * @return {?}
     */
    SwalPortalDirective.prototype.ngOnInit = /**
     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
     * that will receive the consumer's template.
     * @return {?}
     */
    function () {
        // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.
        this.target = this.target || this.swalTargets.content;
        //=> Apply the options provided by the target definition
        void this.swalComponent.update(this.target.options);
        //=> Subscribe to a few hooks frm the parent SwalComponent.
        this.swalComponent.render.pipe(takeUntil(this.destroyed)).subscribe(this.renderHook.bind(this));
        this.swalComponent.beforeOpen.pipe(takeUntil(this.destroyed)).subscribe(this.beforeOpenHook.bind(this));
        this.swalComponent.afterClose.pipe(takeUntil(this.destroyed)).subscribe(this.afterCloseHook.bind(this));
    };
    /**
     * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the
     * parent SwalComponent events.
     */
    /**
     * Signal any {\@link destroyed} consumer that this is over, so they can unsubscribe from the
     * parent SwalComponent events.
     * @return {?}
     */
    SwalPortalDirective.prototype.ngOnDestroy = /**
     * Signal any {\@link destroyed} consumer that this is over, so they can unsubscribe from the
     * parent SwalComponent events.
     * @return {?}
     */
    function () {
        this.destroyed.next();
    };
    /**
     * This render hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
     * {@link beforeOpenHook}), or after Swal.update() is called.
     * This is a good place to render, or re-render, our portal contents.
     */
    /**
     * This render hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
     * {\@link beforeOpenHook}), or after Swal.update() is called.
     * This is a good place to render, or re-render, our portal contents.
     * @private
     * @return {?}
     */
    SwalPortalDirective.prototype.renderHook = /**
     * This render hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
     * {\@link beforeOpenHook}), or after Swal.update() is called.
     * This is a good place to render, or re-render, our portal contents.
     * @private
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var swal, targetEl;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        //=> Ensure the portal component is created
                        if (!this.portalComponentRef) {
                            this.portalComponentRef = this.createPortalComponent();
                        }
                        //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.
                        // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside
                        // this function is already resolved at this point), so the whole process of re-rendering and re-mounting
                        // the portal component is fully synchronous, causing no blinks in the modal contents.
                        return [4 /*yield*/, this.sweetAlert2Loader.swal];
                    case 1:
                        swal = _a.sent();
                        //=> Find target element
                        targetEl = (/** @type {?} */ (this.target)).element(swal);
                        //=> Replace target's contents with our component
                        // https://jsperf.com/innerhtml-vs-removechild/15
                        while (targetEl.firstChild) {
                            targetEl.removeChild(targetEl.firstChild);
                        }
                        targetEl.appendChild(this.portalComponentRef.location.nativeElement);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This beforeOpen hook runs once (per modal instance), just before the modal is shown on the screen.
     * This is a good place to declare our detached view to the Angular app.
     */
    /**
     * This beforeOpen hook runs once (per modal instance), just before the modal is shown on the screen.
     * This is a good place to declare our detached view to the Angular app.
     * @private
     * @return {?}
     */
    SwalPortalDirective.prototype.beforeOpenHook = /**
     * This beforeOpen hook runs once (per modal instance), just before the modal is shown on the screen.
     * This is a good place to declare our detached view to the Angular app.
     * @private
     * @return {?}
     */
    function () {
        if (!this.portalComponentRef)
            return;
        //=> Make the Angular app aware of that detached view so rendering and change detection can happen
        this.app.attachView(this.portalComponentRef.hostView);
    };
    /**
     * This afterClose hook runs once (per modal instance), just after the modal closing animation terminated.
     * This is a good place to detach and destroy our content, that is not visible anymore.
     */
    /**
     * This afterClose hook runs once (per modal instance), just after the modal closing animation terminated.
     * This is a good place to detach and destroy our content, that is not visible anymore.
     * @private
     * @return {?}
     */
    SwalPortalDirective.prototype.afterCloseHook = /**
     * This afterClose hook runs once (per modal instance), just after the modal closing animation terminated.
     * This is a good place to detach and destroy our content, that is not visible anymore.
     * @private
     * @return {?}
     */
    function () {
        if (!this.portalComponentRef)
            return;
        //=> Detach the portal component from the app and destroy it
        this.app.detachView(this.portalComponentRef.hostView);
        this.portalComponentRef.destroy();
        this.portalComponentRef = void 0;
    };
    /**
     * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.
     */
    /**
     * Creates the {\@link SwalPortalComponent} and gives it the customer's template ref.
     * @private
     * @return {?}
     */
    SwalPortalDirective.prototype.createPortalComponent = /**
     * Creates the {\@link SwalPortalComponent} and gives it the customer's template ref.
     * @private
     * @return {?}
     */
    function () {
        //=> Create the SwalPortalComponent that will hold our content
        /** @type {?} */
        var factory = this.resolver.resolveComponentFactory(SwalPortalComponent);
        // Yes, we do not use the third argument that would directly use the target as the component's view
        // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)
        // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be
        // able to restore it at any moment, ie. after the modal has been re-rendered.
        /** @type {?} */
        var componentRef = factory.create(this.injector, []);
        //=> Apply the consumer's template on the component
        componentRef.instance.template = this.templateRef;
        return componentRef;
    };
    SwalPortalDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[swalPortal]'
                },] }
    ];
    /** @nocollapse */
    SwalPortalDirective.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: Injector },
        { type: ApplicationRef },
        { type: TemplateRef },
        { type: SweetAlert2LoaderService },
        { type: SwalPortalTargets },
        { type: SwalComponent, decorators: [{ type: Host }] }
    ]; };
    SwalPortalDirective.propDecorators = {
        target: [{ type: Input, args: ['swalPortal',] }]
    };
    return SwalPortalDirective;
}());
if (false) {
    /**
     * Takes a portal target or nothing (then it will target the text content zone by default).
     *
     * See the {\@link SwalPortalTargets} service to see the available targets.
     * See the class doc block for more informations.
     * @type {?}
     */
    SwalPortalDirective.prototype.target;
    /**
     * Holds the component reference of the controlled SwalPortalComponent to destroy it when no longer needed.
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.portalComponentRef;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.destroyed;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.resolver;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.injector;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.app;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.sweetAlert2Loader;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.swalTargets;
    /**
     * @type {?}
     * @private
     */
    SwalPortalDirective.prototype.swalComponent;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/sweetalert2.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Sweetalert2ModuleConfig() { }
if (false) {
    /** @type {?|undefined} */
    Sweetalert2ModuleConfig.prototype.provideSwal;
    /** @type {?|undefined} */
    Sweetalert2ModuleConfig.prototype.fireOnInit;
    /** @type {?|undefined} */
    Sweetalert2ModuleConfig.prototype.dismissOnDestroy;
}
/**
 * @return {?}
 */
function provideDefaultSwal() {
    return import('sweetalert2');
}
var SweetAlert2Module = /** @class */ (function () {
    function SweetAlert2Module() {
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    SweetAlert2Module.forRoot = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        return {
            ngModule: SweetAlert2Module,
            providers: [
                SweetAlert2LoaderService,
                { provide: swalProviderToken, useValue: options.provideSwal || provideDefaultSwal },
                { provide: fireOnInitToken, useValue: options.fireOnInit || false },
                { provide: dismissOnDestroyToken, useValue: options.dismissOnDestroy || true }
            ]
        };
    };
    /**
     * @param {?=} options
     * @return {?}
     */
    SweetAlert2Module.forChild = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        return {
            ngModule: SweetAlert2Module,
            providers: __spread(options.provideSwal ? [
                SweetAlert2LoaderService,
                { provide: swalProviderToken, useValue: options.provideSwal }
            ] : [], options.fireOnInit !== undefined ? [
                { provide: fireOnInitToken, useValue: options.fireOnInit }
            ] : [], options.dismissOnDestroy !== undefined ? [
                { provide: dismissOnDestroyToken, useValue: options.dismissOnDestroy }
            ] : [])
        };
    };
    SweetAlert2Module.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        SwalDirective, SwalComponent, SwalPortalDirective, SwalPortalComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        SwalComponent, SwalPortalDirective, SwalDirective
                    ],
                    entryComponents: [
                        SwalComponent, SwalPortalComponent
                    ]
                },] }
    ];
    return SweetAlert2Module;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: sweetalert2-ngx-sweetalert2.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { SwalComponent, SwalDirective, SwalPortalTargets, SweetAlert2LoaderService, SweetAlert2Module, provideDefaultSwal as ɵa, swalProviderToken as ɵb, fireOnInitToken as ɵc, dismissOnDestroyToken as ɵd, SwalPortalDirective as ɵe, SwalPortalComponent as ɵf };
//# sourceMappingURL=sweetalert2-ngx-sweetalert2.js.map
