/**
 * @fileoverview added by tsickle
 * Generated from: lib/swal.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { dismissOnDestroyToken, fireOnInitToken } from './di';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of \@Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many \@Inputs,
 *     take a look at [swalOptions], that lets you pass a full {\@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't \@Inputs but \@Outputs: onBeforeOpen, onOpen, onClose and onAfterClose
 *     (but without "on*" prefix to respect community standards).
 *     However, preConfirm and inputValidator are still \@Inputs because there are not event handlers, there can't be
 *     multiple listeners and we need the values they can/must return.
 */
export class SwalComponent {
    /**
     * @param {?} sweetAlert2Loader
     * @param {?} moduleLevelFireOnInit
     * @param {?} moduleLevelDismissOnDestroy
     */
    constructor(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.moduleLevelFireOnInit = moduleLevelFireOnInit;
        this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
        /**
         * Emits an event when the modal DOM element has been created.
         * Useful to perform DOM mutations before the modal is shown.
         */
        this.beforeOpen = new EventEmitter();
        /**
         * Emits an event when the modal is shown.
         */
        this.open = new EventEmitter();
        /**
         * Emits an event when the modal DOM is rendered.
         */
        this.render = new EventEmitter();
        /**
         * Emits an event when the modal will be closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.close = new EventEmitter();
        /**
         * Emits an event after the modal had been closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
         * The reason is `undefined` when {\@link dismiss} is called.
         *
         * Example:
         *     <swal (cancel)="handleCancel($event)"></swal>
         *
         *     public handleCancel(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
        /**
         * This Set retains the properties that have been changed from \@Inputs, so we can know precisely
         * what options we have to send to {\@link Swal.fire}.
         */
        this.touchedProps = new Set();
        /**
         * A function of signature `(propName: string): void` that adds a given property name to the list of
         * touched properties, ie. {\@link touchedProps}.
         */
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        /**
         * Is the SweetAlert2 modal represented by this component currently opened?
         */
        this.isCurrentlyShown = false;
    }
    /**
     * An object of SweetAlert2 native options, useful if:
     *  - you don't want to use the \@Inputs for practical/philosophical reasons ;
     *  - there are missing \@Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
     *
     * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
     *     previous properties you want to erase again.
     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
     *
     * /!\ Be aware that the options defined in this object will override the \@Inputs of the same name.
     * @param {?} options
     * @return {?}
     */
    set swalOptions(options) {
        //=> Update properties
        Object.assign(this, options);
        //=> Mark changed properties as touched
        /** @type {?} */
        const touchedKeys = (/** @type {?} */ (Object.keys(options)));
        touchedKeys.forEach(this.markTouched);
    }
    /**
     * Computes the options object that will get passed to SweetAlert2.
     * Only the properties that have been set at least once on this component will be returned.
     * Mostly for internal usage.
     * @return {?}
     */
    get swalOptions() {
        /** @type {?} */
        const options = {};
        //=> We will compute the options object based on the option keys that are known to have changed.
        //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
        //   avoiding side effects.
        this.touchedProps.forEach((/**
         * @param {?} prop
         * @return {?}
         */
        prop => {
            options[prop] = this[(/** @type {?} */ (prop))];
        }));
        return options;
    }
    /**
     * @param {?} visible
     * @return {?}
     */
    set swalVisible(visible) {
        visible ? this.fire() : this.dismiss();
    }
    /**
     * @return {?}
     */
    get swalVisible() {
        return this.isCurrentlyShown;
    }
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     * @return {?}
     */
    ngOnInit() {
        //=> Preload SweetAlert2 library in case this component is activated.
        this.sweetAlert2Loader.preloadSweetAlertLibrary();
    }
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const fireOnInit = this.swalFireOnInit === undefined
            ? this.moduleLevelFireOnInit
            : this.swalFireOnInit;
        fireOnInit && this.fire();
    }
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
        //   send it with the next fire() or update() calls.
        Object.keys(changes)
            //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
            .filter((/**
         * @param {?} prop
         * @return {?}
         */
        (prop) => !prop.startsWith('swal')))
            .forEach(this.markTouched);
        //=> Eventually trigger re-render if the modal is open.
        void this.update();
    }
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     * @return {?}
     */
    ngOnDestroy() {
        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
        /** @type {?} */
        const dismissOnDestroy = this.swalDismissOnDestroy === undefined
            ? this.moduleLevelDismissOnDestroy
            : this.swalDismissOnDestroy;
        dismissOnDestroy && this.dismiss();
    }
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     * @return {?}
     */
    fire() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const swal = yield this.sweetAlert2Loader.swal;
            //=> Build the SweetAlert2 options
            /** @type {?} */
            const options = Object.assign({}, this.swalOptions, { onBeforeOpen: (/**
                 * @param {?} modalElement
                 * @return {?}
                 */
                (modalElement) => {
                    this.beforeOpen.emit({ modalElement });
                }), onOpen: (/**
                 * @param {?} modalElement
                 * @return {?}
                 */
                (modalElement) => {
                    this.isCurrentlyShown = true;
                    this.open.emit({ modalElement });
                }), onRender: (/**
                 * @param {?} modalElement
                 * @return {?}
                 */
                (modalElement) => {
                    this.render.emit({ modalElement });
                }), onClose: (/**
                 * @param {?} modalElement
                 * @return {?}
                 */
                (modalElement) => {
                    this.isCurrentlyShown = false;
                    this.close.emit({ modalElement });
                }), onAfterClose: (/**
                 * @return {?}
                 */
                () => {
                    this.afterClose.emit();
                }) });
            //=> Show the Swal! And wait for confirmation or dimissal.
            /** @type {?} */
            const result = yield swal.fire(options);
            //=> Emit on (confirm) or (cancel)
            if ('value' in result) {
                this.confirm.emit(result.value);
            }
            else {
                this.cancel.emit(result.dismiss);
            }
            return result;
        });
    }
    /**
     * Closes the modal, if opened.
     *
     * @param {?=} result The value that the modal will resolve with, triggering either (confirm) or (cancel).
     *               If the argument is not passed, (dimiss) will emit `undefined`.
     *               See {\@link Swal.close}
     * @return {?}
     */
    dismiss(result) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.isCurrentlyShown)
                return;
            /** @type {?} */
            const swal = yield this.sweetAlert2Loader.swal;
            swal.close(result);
        });
    }
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param {?=} options
     * @return {?}
     */
    update(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (options) {
                this.swalOptions = options;
            }
            if (!this.isCurrentlyShown)
                return;
            /** @type {?} */
            const swal = yield this.sweetAlert2Loader.swal;
            /** @type {?} */
            const allOptions = this.swalOptions;
            /** @type {?} */
            const updatableOptions = Object.keys(allOptions)
                .filter((/**
             * @param {?} key
             * @return {?}
             */
            (key) => swal.isUpdatableParameter(key)))
                .reduce((/**
             * @param {?} obj
             * @param {?} key
             * @return {?}
             */
            (obj, key) => {
                obj[key] = allOptions[key];
                return obj;
            }), (/** @type {?} */ ({})));
            swal.update(updatableOptions);
        });
    }
}
SwalComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'swal',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
SwalComponent.ctorParameters = () => [
    { type: SweetAlert2LoaderService },
    { type: Boolean, decorators: [{ type: Inject, args: [fireOnInitToken,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [dismissOnDestroyToken,] }] }
];
SwalComponent.propDecorators = {
    title: [{ type: Input }],
    titleText: [{ type: Input }],
    text: [{ type: Input }],
    html: [{ type: Input }],
    footer: [{ type: Input }],
    icon: [{ type: Input }],
    iconHtml: [{ type: Input }],
    backdrop: [{ type: Input }],
    toast: [{ type: Input }],
    target: [{ type: Input }],
    input: [{ type: Input }],
    width: [{ type: Input }],
    padding: [{ type: Input }],
    background: [{ type: Input }],
    position: [{ type: Input }],
    grow: [{ type: Input }],
    showClass: [{ type: Input }],
    hideClass: [{ type: Input }],
    customClass: [{ type: Input }],
    timer: [{ type: Input }],
    animation: [{ type: Input }],
    heightAuto: [{ type: Input }],
    allowOutsideClick: [{ type: Input }],
    allowEscapeKey: [{ type: Input }],
    allowEnterKey: [{ type: Input }],
    stopKeydownPropagation: [{ type: Input }],
    keydownListenerCapture: [{ type: Input }],
    showConfirmButton: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    confirmButtonText: [{ type: Input }],
    cancelButtonText: [{ type: Input }],
    confirmButtonColor: [{ type: Input }],
    cancelButtonColor: [{ type: Input }],
    confirmButtonAriaLabel: [{ type: Input }],
    cancelButtonAriaLabel: [{ type: Input }],
    buttonsStyling: [{ type: Input }],
    reverseButtons: [{ type: Input }],
    focusConfirm: [{ type: Input }],
    focusCancel: [{ type: Input }],
    showCloseButton: [{ type: Input }],
    closeButtonHtml: [{ type: Input }],
    closeButtonAriaLabel: [{ type: Input }],
    showLoaderOnConfirm: [{ type: Input }],
    preConfirm: [{ type: Input }],
    imageUrl: [{ type: Input }],
    imageWidth: [{ type: Input }],
    imageHeight: [{ type: Input }],
    imageAlt: [{ type: Input }],
    inputPlaceholder: [{ type: Input }],
    inputValue: [{ type: Input }],
    inputOptions: [{ type: Input }],
    inputAutoTrim: [{ type: Input }],
    inputAttributes: [{ type: Input }],
    inputValidator: [{ type: Input }],
    validationMessage: [{ type: Input }],
    progressSteps: [{ type: Input }],
    currentProgressStep: [{ type: Input }],
    progressStepsDistance: [{ type: Input }],
    scrollbarPadding: [{ type: Input }],
    swalOptions: [{ type: Input }],
    swalFireOnInit: [{ type: Input }],
    swalDismissOnDestroy: [{ type: Input }],
    swalVisible: [{ type: Input }],
    beforeOpen: [{ type: Output }],
    open: [{ type: Output }],
    render: [{ type: Output }],
    close: [{ type: Output }],
    afterClose: [{ type: Output }],
    confirm: [{ type: Output }],
    cancel: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SwalComponent.prototype.title;
    /** @type {?} */
    SwalComponent.prototype.titleText;
    /** @type {?} */
    SwalComponent.prototype.text;
    /** @type {?} */
    SwalComponent.prototype.html;
    /** @type {?} */
    SwalComponent.prototype.footer;
    /** @type {?} */
    SwalComponent.prototype.icon;
    /** @type {?} */
    SwalComponent.prototype.iconHtml;
    /** @type {?} */
    SwalComponent.prototype.backdrop;
    /** @type {?} */
    SwalComponent.prototype.toast;
    /** @type {?} */
    SwalComponent.prototype.target;
    /** @type {?} */
    SwalComponent.prototype.input;
    /** @type {?} */
    SwalComponent.prototype.width;
    /** @type {?} */
    SwalComponent.prototype.padding;
    /** @type {?} */
    SwalComponent.prototype.background;
    /** @type {?} */
    SwalComponent.prototype.position;
    /** @type {?} */
    SwalComponent.prototype.grow;
    /** @type {?} */
    SwalComponent.prototype.showClass;
    /** @type {?} */
    SwalComponent.prototype.hideClass;
    /** @type {?} */
    SwalComponent.prototype.customClass;
    /** @type {?} */
    SwalComponent.prototype.timer;
    /**
     * @deprecated Use showClass and hideClass instead
     * @type {?}
     */
    SwalComponent.prototype.animation;
    /** @type {?} */
    SwalComponent.prototype.heightAuto;
    /** @type {?} */
    SwalComponent.prototype.allowOutsideClick;
    /** @type {?} */
    SwalComponent.prototype.allowEscapeKey;
    /** @type {?} */
    SwalComponent.prototype.allowEnterKey;
    /** @type {?} */
    SwalComponent.prototype.stopKeydownPropagation;
    /** @type {?} */
    SwalComponent.prototype.keydownListenerCapture;
    /** @type {?} */
    SwalComponent.prototype.showConfirmButton;
    /** @type {?} */
    SwalComponent.prototype.showCancelButton;
    /** @type {?} */
    SwalComponent.prototype.confirmButtonText;
    /** @type {?} */
    SwalComponent.prototype.cancelButtonText;
    /** @type {?} */
    SwalComponent.prototype.confirmButtonColor;
    /** @type {?} */
    SwalComponent.prototype.cancelButtonColor;
    /** @type {?} */
    SwalComponent.prototype.confirmButtonAriaLabel;
    /** @type {?} */
    SwalComponent.prototype.cancelButtonAriaLabel;
    /** @type {?} */
    SwalComponent.prototype.buttonsStyling;
    /** @type {?} */
    SwalComponent.prototype.reverseButtons;
    /** @type {?} */
    SwalComponent.prototype.focusConfirm;
    /** @type {?} */
    SwalComponent.prototype.focusCancel;
    /** @type {?} */
    SwalComponent.prototype.showCloseButton;
    /** @type {?} */
    SwalComponent.prototype.closeButtonHtml;
    /** @type {?} */
    SwalComponent.prototype.closeButtonAriaLabel;
    /** @type {?} */
    SwalComponent.prototype.showLoaderOnConfirm;
    /** @type {?} */
    SwalComponent.prototype.preConfirm;
    /** @type {?} */
    SwalComponent.prototype.imageUrl;
    /** @type {?} */
    SwalComponent.prototype.imageWidth;
    /** @type {?} */
    SwalComponent.prototype.imageHeight;
    /** @type {?} */
    SwalComponent.prototype.imageAlt;
    /** @type {?} */
    SwalComponent.prototype.inputPlaceholder;
    /** @type {?} */
    SwalComponent.prototype.inputValue;
    /** @type {?} */
    SwalComponent.prototype.inputOptions;
    /** @type {?} */
    SwalComponent.prototype.inputAutoTrim;
    /** @type {?} */
    SwalComponent.prototype.inputAttributes;
    /** @type {?} */
    SwalComponent.prototype.inputValidator;
    /** @type {?} */
    SwalComponent.prototype.validationMessage;
    /** @type {?} */
    SwalComponent.prototype.progressSteps;
    /** @type {?} */
    SwalComponent.prototype.currentProgressStep;
    /** @type {?} */
    SwalComponent.prototype.progressStepsDistance;
    /** @type {?} */
    SwalComponent.prototype.scrollbarPadding;
    /**
     * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.
     * When left undefined (default), the value will be inherited from the module configuration, which is `false`.
     *
     * Example:
     *     <swal *ngIf="error" [title]="error.title" [text]="error.text" icon="error" [swalFireOnInit]="true"></swal>
     * @type {?}
     */
    SwalComponent.prototype.swalFireOnInit;
    /**
     * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.
     * When left undefined (default), the value will be inherited from the module configuration, which is `true`.
     * @type {?}
     */
    SwalComponent.prototype.swalDismissOnDestroy;
    /**
     * Emits an event when the modal DOM element has been created.
     * Useful to perform DOM mutations before the modal is shown.
     * @type {?}
     */
    SwalComponent.prototype.beforeOpen;
    /**
     * Emits an event when the modal is shown.
     * @type {?}
     */
    SwalComponent.prototype.open;
    /**
     * Emits an event when the modal DOM is rendered.
     * @type {?}
     */
    SwalComponent.prototype.render;
    /**
     * Emits an event when the modal will be closed.
     * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
     * @type {?}
     */
    SwalComponent.prototype.close;
    /**
     * Emits an event after the modal had been closed.
     * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
     * @type {?}
     */
    SwalComponent.prototype.afterClose;
    /**
     * Emits when the user clicks "Confirm".
     * Bears a value when using "input", resolved "preConfirm", etc.
     *
     * Example:
     *     <swal (confirm)="handleConfirm($event)"></swal>
     *
     *     public handleConfirm(email: string): void {
     *         // ... save user email
     *     }
     * @type {?}
     */
    SwalComponent.prototype.confirm;
    /**
     * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
     * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
     * The reason is `undefined` when {\@link dismiss} is called.
     *
     * Example:
     *     <swal (cancel)="handleCancel($event)"></swal>
     *
     *     public handleCancel(reason: DismissReason | undefined): void {
     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
     *         // ... do something
     *     }
     * @type {?}
     */
    SwalComponent.prototype.cancel;
    /**
     * This Set retains the properties that have been changed from \@Inputs, so we can know precisely
     * what options we have to send to {\@link Swal.fire}.
     * @type {?}
     * @private
     */
    SwalComponent.prototype.touchedProps;
    /**
     * A function of signature `(propName: string): void` that adds a given property name to the list of
     * touched properties, ie. {\@link touchedProps}.
     * @type {?}
     * @private
     */
    SwalComponent.prototype.markTouched;
    /**
     * Is the SweetAlert2 modal represented by this component currently opened?
     * @type {?}
     * @private
     */
    SwalComponent.prototype.isCurrentlyShown;
    /**
     * @type {?}
     * @private
     */
    SwalComponent.prototype.sweetAlert2Loader;
    /**
     * @type {?}
     * @private
     */
    SwalComponent.prototype.moduleLevelFireOnInit;
    /**
     * @type {?}
     * @private
     */
    SwalComponent.prototype.moduleLevelDismissOnDestroy;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyLyIsInNvdXJjZXMiOlsibGliL3N3YWwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFFSCx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQWdDLE1BQU0sRUFDeEcsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGVBQWUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU5RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJ4RSxNQUFNLE9BQU8sYUFBYTs7Ozs7O0lBK010QixZQUNxQixpQkFBMkMsRUFDbEIscUJBQThCLEVBQ3hCLDJCQUFvQztRQUZuRSxzQkFBaUIsR0FBakIsaUJBQWlCLENBQTBCO1FBQ2xCLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBUztRQUN4QixnQ0FBMkIsR0FBM0IsMkJBQTJCLENBQVM7Ozs7O1FBOUV4RSxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQTBCLENBQUM7Ozs7UUFNeEQsU0FBSSxHQUFHLElBQUksWUFBWSxFQUFvQixDQUFDOzs7O1FBTTVDLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBc0IsQ0FBQzs7Ozs7UUFPaEQsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFxQixDQUFDOzs7OztRQU85QyxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQzs7Ozs7Ozs7Ozs7O1FBY3RDLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDOzs7Ozs7Ozs7Ozs7OztRQWdCbEMsV0FBTSxHQUFHLElBQUksWUFBWSxFQUFrQyxDQUFDOzs7OztRQU0zRCxpQkFBWSxHQUFHLElBQUksR0FBRyxFQUEyQixDQUFDOzs7OztRQU1sRCxnQkFBVyxHQUFHLElB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RCxtQ0FBNEQ7O0lBQzVELDBDQUEwRTs7SUFDMUUsdUNBQW9FOztJQUNwRSxzQ0FBa0U7O0lBQ2xFLCtDQUFvRjs7SUFDcEYsK0NBQW9GOztJQUNwRiwwQ0FBMEU7O0lBQzFFLHlDQUF3RTs7SUFDeEUsMENBQTBFOztJQUMxRSx5Q0FBd0U7O0lBQ3hFLDJDQUE0RTs7SUFDNUUsMENBQTBFOztJQUMxRSwrQ0FBb0Y7O0lBQ3BGLDhDQUFrRjs7SUFDbEYsdUNBQW9FOztJQUNwRSx1Q0FBb0U7O0lBQ3BFLHFDQUFnRTs7SUFDaEUsb0NBQThEOztJQUM5RCx3Q0FBc0U7O0lBQ3RFLHdDQUFzRTs7SUFDdEUsNkNBQWdGOztJQUNoRiw0Q0FBOEU7O0lBQzlFLG1DQUE0RDs7SUFDNUQsaUNBQXdEOztJQUN4RCxtQ0FBNEQ7O0lBQzVELG9DQUE4RDs7SUFDOUQsaUNBQXdEOztJQUN4RCx5Q0FBd0U7O0lBQ3hFLG1DQUE0RDs7SUFDNUQscUNBQWdFOztJQUNoRSxzQ0FBa0U7O0lBQ2xFLHdDQUFzRTs7SUFDdEUsdUNBQW9FOztJQUNwRSwwQ0FBMEU7O0lBQzFFLHNDQUFrRTs7SUFDbEUsNENBQThFOztJQUM5RSw4Q0FBa0Y7O0lBQ2xGLHlDQUF3RTs7Ozs7Ozs7O0lBZ0R4RSx1Q0FDZ0M7Ozs7OztJQU1oQyw2Q0FDc0M7Ozs7OztJQWV0QyxtQ0FDd0U7Ozs7O0lBS3hFLDZCQUM0RDs7Ozs7SUFLNUQsK0JBQ2dFOzs7Ozs7SUFNaEUsOEJBQzhEOzs7Ozs7SUFNOUQsbUNBQ3NEOzs7Ozs7Ozs7Ozs7O0lBYXRELGdDQUNrRDs7Ozs7Ozs7Ozs7Ozs7O0lBZWxELCtCQUM0RTs7Ozs7OztJQU01RSxxQ0FBbUU7Ozs7Ozs7SUFNbkUsb0NBQTZFOzs7Ozs7SUFLN0UseUNBQWlDOzs7OztJQUc3QiwwQ0FBNEQ7Ozs7O0lBQzVELDhDQUF3RTs7Ozs7SUFDeEUsb0RBQW9GIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5qZWN0LCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IFN3YWwsIHsgU3dlZXRBbGVydE9wdGlvbnMsIFN3ZWV0QWxlcnRSZXN1bHQgfSBmcm9tICdzd2VldGFsZXJ0Mic7XG5pbXBvcnQgeyBkaXNtaXNzT25EZXN0cm95VG9rZW4sIGZpcmVPbkluaXRUb2tlbiB9IGZyb20gJy4vZGknO1xuaW1wb3J0ICogYXMgZXZlbnRzIGZyb20gJy4vc3dhbC1ldmVudHMnO1xuaW1wb3J0IHsgU3dlZXRBbGVydDJMb2FkZXJTZXJ2aWNlIH0gZnJvbSAnLi9zd2VldGFsZXJ0Mi1sb2FkZXIuc2VydmljZSc7XG5cbi8qKlxuICogPHN3YWw+IGNvbXBvbmVudC4gU2VlIHRoZSBSRUFETUUubWQgZm9yIHVzYWdlLlxuICpcbiAqIEl0IGNvbnRhaW5zIGEgYnVuY2ggb2YgQElucHV0cyB0aGF0IGhhdmUgYSBwZXJmZWN0IDE6MSBtYXBwaW5nIHdpdGggU3dlZXRBbGVydDIgb3B0aW9ucy5cbiAqIFRoZWlyIHR5cGVzIGFyZSBkaXJlY3RseSBjb21pbmcgZnJvbSBTd2VldEFsZXJ0MiB0eXBlcyBkZWZpbnRpdGlvbnMsIG1lYW5pbmcgdGhhdCBuZ3gtc3dlZXRhbGVydDIgaXMgdGlnaHRseSBjb3VwbGVkXG4gKiB0byBTd2VldEFsZXJ0MiwgYnV0IGFsc28gaXMgdHlwZS1zYWZlLlxuICpcbiAqICg/KSBJZiB5b3Ugd2FudCB0byB1c2UgYW4gb2JqZWN0IHRoYXQgZGVjbGFyZXMgdGhlIFN3ZWV0QWxlcnQyIG9wdGlvbnMgYWxsIGF0IG9uY2UgcmF0aGVyIHRoYW4gbWFueSBASW5wdXRzLFxuICogICAgIHRha2UgYSBsb29rIGF0IFtzd2FsT3B0aW9uc10sIHRoYXQgbGV0cyB5b3UgcGFzcyBhIGZ1bGwge0BsaW5rIFN3ZWV0QWxlcnRPcHRpb25zfSBvYmplY3QuXG4gKlxuICogKD8pIElmIHlvdSBhcmUgcmVhZGluZyB0aGUgVHlwZVNjcmlwdCBzb3VyY2Ugb2YgdGhpcyBjb21wb25lbnQsIHlvdSBtYXkgdGhpbmsgdGhhdCBpdCdzIGEgbG90IG9mIGNvZGUuXG4gKiAgICAgQmUgc3VyZSB0aGF0IGEgbG90IG9mIHRoaXMgY29kZSBpcyB0eXBlcyBhbmQgQW5ndWxhciBib2lsZXJwbGF0ZS4gQ29tcGlsZWQgYW5kIG1pbmlmaWVkIGNvZGUgaXMgbXVjaCBzbWFsbGVyLlxuICogICAgIElmIHlvdSBhcmUgcmVhbGx5IGNvbmNlcm5lZCBhYm91dCBwZXJmb3JtYW5jZSBhbmQvb3IgZG9uJ3QgY2FyZSBhYm91dCB0aGUgQVBJIGFuZCBpdHMgY29udmVuaWVudCBpbnRlZ3JhdGlvblxuICogICAgIHdpdGggQW5ndWxhciAobm90YWJseSBjaGFuZ2UgZGV0ZWN0aW9uIGFuZCB0cmFuc2NsdXNpb24pLCB5b3UgbWF5IHRvdGFsbHkgdXNlIFN3ZWV0QWxlcnQyIG5hdGl2ZWx5IGFzIHdlbGwgOylcbiAqXG4gKiAvIVxcIFNvbWUgU3dlZXRBbGVydCBvcHRpb25zIGFyZW4ndCBASW5wdXRzIGJ1dCBAT3V0cHV0czogb25CZWZvcmVPcGVuLCBvbk9wZW4sIG9uQ2xvc2UgYW5kIG9uQWZ0ZXJDbG9zZVxuICogICAgIChidXQgd2l0aG91dCBcIm9uKlwiIHByZWZpeCB0byByZXNwZWN0IGNvbW11bml0eSBzdGFuZGFyZHMpLlxuICogICAgIEhvd2V2ZXIsIHByZUNvbmZpcm0gYW5kIGlucHV0VmFsaWRhdG9yIGFyZSBzdGlsbCBASW5wdXRzIGJlY2F1c2UgdGhlcmUgYXJlIG5vdCBldmVudCBoYW5kbGVycywgdGhlcmUgY2FuJ3QgYmVcbiAqICAgICBtdWx0aXBsZSBsaXN0ZW5lcnMgYW5kIHdlIG5lZWQgdGhlIHZhbHVlcyB0aGV5IGNhbi9tdXN0IHJldHVybi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNvbXBvbmVudC1zZWxlY3RvclxuICAgIHNlbGVjdG9yOiAnc3dhbCcsXG4gICAgdGVtcGxhdGU6ICcnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGl0bGU6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aXRsZVRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZVRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ3RleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2h0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9vdGVyOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9vdGVyJ107XG4gICAgQElucHV0KCkgcHVibGljIGljb246IFN3ZWV0QWxlcnRPcHRpb25zWydpY29uJ107XG4gICAgQElucHV0KCkgcHVibGljIGljb25IdG1sOiBTd2VldEFsZXJ0T3B0aW9uc1snaWNvbkh0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYmFja2Ryb3A6IFN3ZWV0QWxlcnRPcHRpb25zWydiYWNrZHJvcCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0b2FzdDogU3dlZXRBbGVydE9wdGlvbnNbJ3RvYXN0J107XG4gICAgQElucHV0KCkgcHVibGljIHRhcmdldDogU3dlZXRBbGVydE9wdGlvbnNbJ3RhcmdldCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dDogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0J107XG4gICAgQElucHV0KCkgcHVibGljIHdpZHRoOiBTd2VldEFsZXJ0T3B0aW9uc1snd2lkdGgnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcGFkZGluZzogU3dlZXRBbGVydE9wdGlvbnNbJ3BhZGRpbmcnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYmFja2dyb3VuZDogU3dlZXRBbGVydE9wdGlvbnNbJ2JhY2tncm91bmQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcG9zaXRpb246IFN3ZWV0QWxlcnRPcHRpb25zWydwb3NpdGlvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBncm93OiBTd2VldEFsZXJ0T3B0aW9uc1snZ3JvdyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q2xhc3MnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaGlkZUNsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snaGlkZUNsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIGN1c3RvbUNsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snY3VzdG9tQ2xhc3MnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGltZXI6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aW1lciddO1xuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2Ugc2hvd0NsYXNzIGFuZCBoaWRlQ2xhc3MgaW5zdGVhZCAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbmltYXRpb246IFN3ZWV0QWxlcnRPcHRpb25zWydhbmltYXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaGVpZ2h0QXV0bzogU3dlZXRBbGVydE9wdGlvbnNbJ2hlaWdodEF1dG8nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dPdXRzaWRlQ2xpY2s6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd091dHNpZGVDbGljayddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd0VzY2FwZUtleTogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93RXNjYXBlS2V5J107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93RW50ZXJLZXk6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd0VudGVyS2V5J107XG4gICAgQElucHV0KCkgcHVibGljIHN0b3BLZXlkb3duUHJvcGFnYXRpb246IFN3ZWV0QWxlcnRPcHRpb25zWydzdG9wS2V5ZG93blByb3BhZ2F0aW9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGtleWRvd25MaXN0ZW5lckNhcHR1cmU6IFN3ZWV0QWxlcnRPcHRpb25zWydrZXlkb3duTGlzdGVuZXJDYXB0dXJlJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDb25maXJtQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NvbmZpcm1CdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NhbmNlbEJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDYW5jZWxCdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY29uZmlybUJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uVGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25UZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uVGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uQ29sb3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYnV0dG9uc1N0eWxpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydidXR0b25zU3R5bGluZyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyByZXZlcnNlQnV0dG9uczogU3dlZXRBbGVydE9wdGlvbnNbJ3JldmVyc2VCdXR0b25zJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvY3VzQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ2ZvY3VzQ29uZmlybSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmb2N1c0NhbmNlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2ZvY3VzQ2FuY2VsJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDbG9zZUJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDbG9zZUJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjbG9zZUJ1dHRvbkh0bWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjbG9zZUJ1dHRvbkh0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2xvc2VCdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjbG9zZUJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93TG9hZGVyT25Db25maXJtOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0xvYWRlck9uQ29uZmlybSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcmVDb25maXJtOiBTd2VldEFsZXJ0T3B0aW9uc1sncHJlQ29uZmlybSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZVVybDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlVXJsJ107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlV2lkdGg6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZVdpZHRoJ107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlSGVpZ2h0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VIZWlnaHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VBbHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZUFsdCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFBsYWNlaG9sZGVyOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRQbGFjZWhvbGRlciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFZhbHVlOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRWYWx1ZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dE9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dE9wdGlvbnMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRBdXRvVHJpbTogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0QXV0b1RyaW0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRBdHRyaWJ1dGVzOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRBdHRyaWJ1dGVzJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0VmFsaWRhdG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRWYWxpZGF0b3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdmFsaWRhdGlvbk1lc3NhZ2U6IFN3ZWV0QWxlcnRPcHRpb25zWyd2YWxpZGF0aW9uTWVzc2FnZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcm9ncmVzc1N0ZXBzOiBTd2VldEFsZXJ0T3B0aW9uc1sncHJvZ3Jlc3NTdGVwcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjdXJyZW50UHJvZ3Jlc3NTdGVwOiBTd2VldEFsZXJ0T3B0aW9uc1snY3VycmVudFByb2dyZXNzU3RlcCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcm9ncmVzc1N0ZXBzRGlzdGFuY2U6IFN3ZWV0QWxlcnRPcHRpb25zWydwcm9ncmVzc1N0ZXBzRGlzdGFuY2UnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2Nyb2xsYmFyUGFkZGluZzogU3dlZXRBbGVydE9wdGlvbnNbJ3Njcm9sbGJhclBhZGRpbmcnXTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBvZiBTd2VldEFsZXJ0MiBuYXRpdmUgb3B0aW9ucywgdXNlZnVsIGlmOlxuICAgICAqICAtIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgQElucHV0cyBmb3IgcHJhY3RpY2FsL3BoaWxvc29waGljYWwgcmVhc29ucyA7XG4gICAgICogIC0gdGhlcmUgYXJlIG1pc3NpbmcgQElucHV0cyBiZWNhdXNlIG5neC1zd2VldGFsZXJ0MiBpc24ndCB1cC10by1kYXRlIHdpdGggU3dlZXRBbGVydDIncyBsYXRlc3QgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIC8hXFwgUGxlYXNlIG5vdGUgdGhhdCBzZXR0aW5nIHRoaXMgcHJvcGVydHkgZG9lcyBOT1QgZXJhc2Ugd2hhdCBoYXMgYmVlbiBzZXQgYmVmb3JlIHVubGVzcyB5b3Ugc3BlY2lmeSB0aGVcbiAgICAgKiAgICAgcHJldmlvdXMgcHJvcGVydGllcyB5b3Ugd2FudCB0byBlcmFzZSBhZ2Fpbi5cbiAgICAgKiAgICAgSWUuIHNldHRpbmcgeyB0aXRsZTogJ1RpdGxlJyB9IGFuZCB0aGVuIHsgdGV4dDogJ1RleHQnIH0gd2lsbCBnaXZlIHsgdGl0bGU6ICdUaXRsZScsIHRleHQ6ICdUZXh0JyB9LlxuICAgICAqXG4gICAgICogLyFcXCBCZSBhd2FyZSB0aGF0IHRoZSBvcHRpb25zIGRlZmluZWQgaW4gdGhpcyBvYmplY3Qgd2lsbCBvdmVycmlkZSB0aGUgQElucHV0cyBvZiB0aGUgc2FtZSBuYW1lLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBzd2FsT3B0aW9ucyhvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucykge1xuICAgICAgICAvLz0+IFVwZGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy89PiBNYXJrIGNoYW5nZWQgcHJvcGVydGllcyBhcyB0b3VjaGVkXG4gICAgICAgIGNvbnN0IHRvdWNoZWRLZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucykgYXMgQXJyYXk8a2V5b2YgU3dlZXRBbGVydE9wdGlvbnM+O1xuICAgICAgICB0b3VjaGVkS2V5cy5mb3JFYWNoKHRoaXMubWFya1RvdWNoZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBvcHRpb25zIG9iamVjdCB0aGF0IHdpbGwgZ2V0IHBhc3NlZCB0byBTd2VldEFsZXJ0Mi5cbiAgICAgKiBPbmx5IHRoZSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHNldCBhdCBsZWFzdCBvbmNlIG9uIHRoaXMgY29tcG9uZW50IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogTW9zdGx5IGZvciBpbnRlcm5hbCB1c2FnZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHN3YWxPcHRpb25zKCk6IFN3ZWV0QWxlcnRPcHRpb25zIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uczogeyBbUCBpbiBrZXlvZiBTd2VldEFsZXJ0T3B0aW9uc106IGFueSB9ID0ge307XG5cbiAgICAgICAgLy89PiBXZSB3aWxsIGNvbXB1dGUgdGhlIG9wdGlvbnMgb2JqZWN0IGJhc2VkIG9uIHRoZSBvcHRpb24ga2V5cyB0aGF0IGFyZSBrbm93biB0byBoYXZlIGNoYW5nZWQuXG4gICAgICAgIC8vICAgVGhhdCBhdm9pZHMgcGFzc2luZyBhIGdpZ2FudGljIG9iamVjdCB0byBTd2VldEFsZXJ0MiwgbWFraW5nIGRlYnVnZ2luZyBlYXNpZXIgYW5kIHBvdGVudGlhbGx5XG4gICAgICAgIC8vICAgYXZvaWRpbmcgc2lkZSBlZmZlY3RzLlxuICAgICAgICB0aGlzLnRvdWNoZWRQcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgb3B0aW9uc1twcm9wXSA9IHRoaXNbcHJvcCBhcyBrZXlvZiB0aGlzXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBmaXJlIHRoZSBtb2RhbCBhcyBzb29uIGFzIHRoZSA8c3dhbD4gY29tcG9uZW50IGlzIGNyZWF0ZWQgYW5kIGluaXRpYWxpemVkIGluIHRoZSB2aWV3LlxuICAgICAqIFdoZW4gbGVmdCB1bmRlZmluZWQgKGRlZmF1bHQpLCB0aGUgdmFsdWUgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgbW9kdWxlIGNvbmZpZ3VyYXRpb24sIHdoaWNoIGlzIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAqbmdJZj1cImVycm9yXCIgW3RpdGxlXT1cImVycm9yLnRpdGxlXCIgW3RleHRdPVwiZXJyb3IudGV4dFwiIGljb249XCJlcnJvclwiIFtzd2FsRmlyZU9uSW5pdF09XCJ0cnVlXCI+PC9zd2FsPlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN3YWxGaXJlT25Jbml0PzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZGlzbWlzcyB0aGUgbW9kYWwgd2hlbiB0aGUgPHN3YWw+IGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgYnkgQW5ndWxhciAoZm9yIGFueSByZWFzb24pIG9yIG5vdC5cbiAgICAgKiBXaGVuIGxlZnQgdW5kZWZpbmVkIChkZWZhdWx0KSwgdGhlIHZhbHVlIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gdGhlIG1vZHVsZSBjb25maWd1cmF0aW9uLCB3aGljaCBpcyBgdHJ1ZWAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3dhbERpc21pc3NPbkRlc3Ryb3k/OiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHN3YWxWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdmlzaWJsZSA/IHRoaXMuZmlyZSgpIDogdGhpcy5kaXNtaXNzKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBzd2FsVmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDdXJyZW50bHlTaG93bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBtb2RhbCBET00gZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqIFVzZWZ1bCB0byBwZXJmb3JtIERPTSBtdXRhdGlvbnMgYmVmb3JlIHRoZSBtb2RhbCBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgYmVmb3JlT3BlbiA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLkJlZm9yZU9wZW5FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG1vZGFsIGlzIHNob3duLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBvcGVuID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuT3BlbkV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbW9kYWwgRE9NIGlzIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSByZW5kZXIgPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5SZW5kZXJFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG1vZGFsIHdpbGwgYmUgY2xvc2VkLlxuICAgICAqIElmIHlvdSBqdXN0IHdhbnQgdG8ga25vdyB3aGVuIHRoZSB1c2VyIGRpc21pc3NlZCB0aGUgbW9kYWwsIHByZWZlciB0aGUgaGlnaGVyLWxldmVsIChjYW5jZWwpIG91dHB1dC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5DbG9zZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIG1vZGFsIGhhZCBiZWVuIGNsb3NlZC5cbiAgICAgKiBJZiB5b3UganVzdCB3YW50IHRvIGtub3cgd2hlbiB0aGUgdXNlciBkaXNtaXNzZWQgdGhlIG1vZGFsLCBwcmVmZXIgdGhlIGhpZ2hlci1sZXZlbCAoY2FuY2VsKSBvdXRwdXQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGFmdGVyQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNvbmZpcm1cIi5cbiAgICAgKiBCZWFycyBhIHZhbHVlIHdoZW4gdXNpbmcgXCJpbnB1dFwiLCByZXNvbHZlZCBcInByZUNvbmZpcm1cIiwgZXRjLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgPHN3YWwgKGNvbmZpcm0pPVwiaGFuZGxlQ29uZmlybSgkZXZlbnQpXCI+PC9zd2FsPlxuICAgICAqXG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDb25maXJtKGVtYWlsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIC4uLiBzYXZlIHVzZXIgZW1haWxcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBjb25maXJtID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNhbmNlbFwiLCBvciBkaXNtaXNzZXMgdGhlIG1vZGFsIGJ5IGFueSBvdGhlciBhbGxvd2VkIHdheS5cbiAgICAgKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGVtaXQgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByZWFzb24gZm9yIHdoaWNoIHRoZSBTd2VldEFsZXJ0IGhhcyBiZWVuIGNsb3NlZC5cbiAgICAgKiBUaGUgcmVhc29uIGlzIGB1bmRlZmluZWRgIHdoZW4ge0BsaW5rIGRpc21pc3N9IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsIChjYW5jZWwpPVwiaGFuZGxlQ2FuY2VsKCRldmVudClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNhbmNlbChyZWFzb246IERpc21pc3NSZWFzb24gfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIHJlYXNvbiBjYW4gYmUgJ2NhbmNlbCcsICdvdmVybGF5JywgJ2Nsb3NlJywgJ3RpbWVyJyBvciB1bmRlZmluZWQuXG4gICAgICogICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nXG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjxTd2FsLkRpc21pc3NSZWFzb24gfCB1bmRlZmluZWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIFNldCByZXRhaW5zIHRoZSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIGNoYW5nZWQgZnJvbSBASW5wdXRzLCBzbyB3ZSBjYW4ga25vdyBwcmVjaXNlbHlcbiAgICAgKiB3aGF0IG9wdGlvbnMgd2UgaGF2ZSB0byBzZW5kIHRvIHtAbGluayBTd2FsLmZpcmV9LlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgdG91Y2hlZFByb3BzID0gbmV3IFNldDxrZXlvZiBTd2VldEFsZXJ0T3B0aW9ucz4oKTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gb2Ygc2lnbmF0dXJlIGAocHJvcE5hbWU6IHN0cmluZyk6IHZvaWRgIHRoYXQgYWRkcyBhIGdpdmVuIHByb3BlcnR5IG5hbWUgdG8gdGhlIGxpc3Qgb2ZcbiAgICAgKiB0b3VjaGVkIHByb3BlcnRpZXMsIGllLiB7QGxpbmsgdG91Y2hlZFByb3BzfS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IG1hcmtUb3VjaGVkID0gdGhpcy50b3VjaGVkUHJvcHMuYWRkLmJpbmQodGhpcy50b3VjaGVkUHJvcHMpO1xuXG4gICAgLyoqXG4gICAgICogSXMgdGhlIFN3ZWV0QWxlcnQyIG1vZGFsIHJlcHJlc2VudGVkIGJ5IHRoaXMgY29tcG9uZW50IGN1cnJlbnRseSBvcGVuZWQ/XG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0N1cnJlbnRseVNob3duID0gZmFsc2U7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgc3dlZXRBbGVydDJMb2FkZXI6IFN3ZWV0QWxlcnQyTG9hZGVyU2VydmljZSxcbiAgICAgICAgQEluamVjdChmaXJlT25Jbml0VG9rZW4pIHByaXZhdGUgcmVhZG9ubHkgbW9kdWxlTGV2ZWxGaXJlT25Jbml0OiBib29sZWFuLFxuICAgICAgICBASW5qZWN0KGRpc21pc3NPbkRlc3Ryb3lUb2tlbikgcHJpdmF0ZSByZWFkb25seSBtb2R1bGVMZXZlbERpc21pc3NPbkRlc3Ryb3k6IGJvb2xlYW4pIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGxpZmVjeWNsZSBob29rLlxuICAgICAqIEFza3MgdGhlIFN3ZWV0QWxlcnQyIGxvYWRlciBzZXJ2aWNlIHRvIHByZWxvYWQgdGhlIFN3ZWV0QWxlcnQyIGxpYnJhcnksIHNvIGl0IGJlZ2lucyB0byBiZSBsb2FkZWQgb25seSBpZiB0aGVyZVxuICAgICAqIGlzIGEgPHN3YWw+IGNvbXBvbmVudCBzb21ld2hlcmUsIGFuZCBpcyBwcm9iYWJseSBmdWxseSBsb2FkZWQgd2hlbiB0aGUgbW9kYWwgaGFzIHRvIGJlIGRpc3BsYXllZCxcbiAgICAgKiBjYXVzaW5nIG5vIGRlbGF5LlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy89PiBQcmVsb2FkIFN3ZWV0QWxlcnQyIGxpYnJhcnkgaW4gY2FzZSB0aGlzIGNvbXBvbmVudCBpcyBhY3RpdmF0ZWQuXG4gICAgICAgIHRoaXMuc3dlZXRBbGVydDJMb2FkZXIucHJlbG9hZFN3ZWV0QWxlcnRMaWJyYXJ5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBGaXJlcyB0aGUgbW9kYWwsIGlmIHRoZSBjb21wb25lbnQgb3IgbW9kdWxlIGlzIGNvbmZpZ3VyZWQgdG8gZG8gc28uXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZmlyZU9uSW5pdCA9IHRoaXMuc3dhbEZpcmVPbkluaXQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0aGlzLm1vZHVsZUxldmVsRmlyZU9uSW5pdFxuICAgICAgICAgICAgOiB0aGlzLnN3YWxGaXJlT25Jbml0O1xuXG4gICAgICAgIGZpcmVPbkluaXQgJiYgdGhpcy5maXJlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBVcGRhdGVzIHRoZSBTd2VldEFsZXJ0IG9wdGlvbnMsIGFuZCBpZiB0aGUgbW9kYWwgaXMgb3BlbmVkLCBhc2tzIFN3ZWV0QWxlcnQgdG8gcmVuZGVyIGl0IGFnYWluLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIC8vPT4gRm9yIGVhY2ggY2hhbmdlZCBASW5wdXQgdGhhdCBtYXRjaGVzIGEgU3dlZXRBbGVydDIgb3B0aW9uLCBtYXJrIGFzIHRvdWNoZWQgc28gd2UgY2FuXG4gICAgICAgIC8vICAgc2VuZCBpdCB3aXRoIHRoZSBuZXh0IGZpcmUoKSBvciB1cGRhdGUoKSBjYWxscy5cbiAgICAgICAgT2JqZWN0LmtleXMoY2hhbmdlcylcbiAgICAgICAgICAgIC8vPT4gSWYgdGhlIGZpbHRlcmluZyBsb2dpYyBiZWNvbWVzIG1vcmUgY29tcGxleCBoZXJlLCB3ZSBjYW4gdXNlIFN3YWwuaXNWYWxpZFBhcmFtZXRlclxuICAgICAgICAgICAgLmZpbHRlcigocHJvcCk6IHByb3AgaXMga2V5b2YgU3dlZXRBbGVydE9wdGlvbnMgPT4gIXByb3Auc3RhcnRzV2l0aCgnc3dhbCcpKVxuICAgICAgICAgICAgLmZvckVhY2godGhpcy5tYXJrVG91Y2hlZCk7XG5cbiAgICAgICAgLy89PiBFdmVudHVhbGx5IHRyaWdnZXIgcmUtcmVuZGVyIGlmIHRoZSBtb2RhbCBpcyBvcGVuLlxuICAgICAgICB2b2lkIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBDbG9zZXMgdGhlIFN3ZWV0QWxlcnQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIC8vPT4gUmVsZWFzZSB0aGUgbW9kYWwgaWYgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgYW5kIGlmIHRoYXQgYmVoYXZpb3VyIGlzIG5vdCBkaXNhYmxlZC5cbiAgICAgICAgY29uc3QgZGlzbWlzc09uRGVzdHJveSA9IHRoaXMuc3dhbERpc21pc3NPbkRlc3Ryb3kgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0aGlzLm1vZHVsZUxldmVsRGlzbWlzc09uRGVzdHJveVxuICAgICAgICAgICAgOiB0aGlzLnN3YWxEaXNtaXNzT25EZXN0cm95O1xuXG4gICAgICAgIGRpc21pc3NPbkRlc3Ryb3kgJiYgdGhpcy5kaXNtaXNzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIFN3ZWV0QWxlcnQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBTd2VldEFsZXJ0MiBwcm9taXNlIGZvciBjb252ZW5pZW5jZSBhbmQgdXNlIGluIGNvZGUgYmVoaW5kIHRlbXBsYXRlcy5cbiAgICAgKiBPdGhlcndpc2UsIChjb25maXJtKT1cIm15SGFuZGxlcigkZXZlbnQpXCIgYW5kIChjYW5jZWwpPVwibXlIYW5kbGVyKCRldmVudClcIiBjYW4gYmUgdXNlZCBpbiB0ZW1wbGF0ZXMuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGZpcmUoKTogUHJvbWlzZTxTd2VldEFsZXJ0UmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IHN3YWwgPSBhd2FpdCB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnN3YWw7XG5cbiAgICAgICAgLy89PiBCdWlsZCB0aGUgU3dlZXRBbGVydDIgb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vPT4gTWVyZ2Ugd2l0aCBjYWxjdWxhdGVkIG9wdGlvbnMgc2V0IGZvciB0aGF0IHNwZWNpZmljIHN3YWxcbiAgICAgICAgICAgIC4uLnRoaXMuc3dhbE9wdGlvbnMsXG5cbiAgICAgICAgICAgIC8vPT4gSGFuZGxlIG1vZGFsIGxpZmVjeWNsZSBldmVudHNcbiAgICAgICAgICAgIG9uQmVmb3JlT3BlbjogKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVmb3JlT3Blbi5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uT3BlbjogKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlTaG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZW5kZXI6IChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlci5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2xvc2U6IChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ3VycmVudGx5U2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BZnRlckNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlckNsb3NlLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLz0+IFNob3cgdGhlIFN3YWwhIEFuZCB3YWl0IGZvciBjb25maXJtYXRpb24gb3IgZGltaXNzYWwuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN3YWwuZmlyZShvcHRpb25zKTtcblxuICAgICAgICAvLz0+IEVtaXQgb24gKGNvbmZpcm0pIG9yIChjYW5jZWwpXG4gICAgICAgIGlmICgndmFsdWUnIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5jb25maXJtLmVtaXQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsLmVtaXQocmVzdWx0LmRpc21pc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIG1vZGFsLCBpZiBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSB2YWx1ZSB0aGF0IHRoZSBtb2RhbCB3aWxsIHJlc29sdmUgd2l0aCwgdHJpZ2dlcmluZyBlaXRoZXIgKGNvbmZpcm0pIG9yIChjYW5jZWwpLlxuICAgICAqICAgICAgICAgICAgICAgSWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBwYXNzZWQsIChkaW1pc3MpIHdpbGwgZW1pdCBgdW5kZWZpbmVkYC5cbiAgICAgKiAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgU3dhbC5jbG9zZX1cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZGlzbWlzcyhyZXN1bHQ/OiBTd2VldEFsZXJ0UmVzdWx0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghdGhpcy5pc0N1cnJlbnRseVNob3duKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc3dhbCA9IGF3YWl0IHRoaXMuc3dlZXRBbGVydDJMb2FkZXIuc3dhbDtcbiAgICAgICAgc3dhbC5jbG9zZShyZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgU3dlZXRBbGVydDIgb3B0aW9ucyB3aGlsZSB0aGUgbW9kYWwgaXMgb3BlbmVkLCBjYXVzaW5nIHRoZSBtb2RhbCB0byByZS1yZW5kZXIuXG4gICAgICogSWYgdGhlIG1vZGFsIGlzIG5vdCBvcGVuZWQsIHRoZSBjb21wb25lbnQgb3B0aW9ucyB3aWxsIHNpbXBseSBiZSB1cGRhdGVkIGFuZCB0aGF0J3MgaXQuXG4gICAgICpcbiAgICAgKiAvIVxcIFBsZWFzZSBub3RlIHRoYXQgbm90IGFsbCBTd2VldEFsZXJ0MiBvcHRpb25zIGFyZSB1cGRhdGFibGUgd2hpbGUgdGhlIG1vZGFsIGlzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHVwZGF0ZShvcHRpb25zPzogU3dlZXRBbGVydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5U2hvd24pIHJldHVybjtcblxuICAgICAgICBjb25zdCBzd2FsID0gYXdhaXQgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5zd2FsO1xuICAgICAgICBjb25zdCBhbGxPcHRpb25zID0gdGhpcy5zd2FsT3B0aW9ucztcblxuICAgICAgICBjb25zdCB1cGRhdGFibGVPcHRpb25zID0gT2JqZWN0LmtleXMoYWxsT3B0aW9ucylcbiAgICAgICAgICAgIC5maWx0ZXIoKGtleSk6IGtleSBpcyBrZXlvZiBTd2VldEFsZXJ0T3B0aW9ucyA9PiBzd2FsLmlzVXBkYXRhYmxlUGFyYW1ldGVyKGtleSkpXG4gICAgICAgICAgICAucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gYWxsT3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LCB7fSBhcyB7IFtQIGluIGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zXTogYW55IH0pO1xuXG4gICAgICAgIHN3YWwudXBkYXRlKHVwZGF0YWJsZU9wdGlvbnMpO1xuICAgIH1cbn1cbiJdfQ==